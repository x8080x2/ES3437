<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Mailer - V6</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-size: 18px;
        }

        body {
            font-family: 'Fira Code', monospace;
            background-color: #F4F6F8; /* Light Gray */
            color: #37474F; /* Slate Gray */
            caret-color: #FFA726; /* Soft Orange, accent for caret */
            overflow: hidden;
            height: 50vh;
        }

        .window-controls {
            height: 12px;
            background-color: #3F51B5; /* Indigo Blue */
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 19px;
            border-bottom: 1px solid #3F51B5;
        }

        .control-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
            cursor: pointer;
			
        }
        .control-button.minimize { background: #43A047; } /* Success */
        .control-button.close    { background: #E57373; } /* Error */

        .main-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 220px;
            background-color: #3F51B5; /* Indigo Blue */
            border-right: 1px solid #3F51B5;
            padding: 12px;
            display: flex;
            flex-direction: column;
        }

        .logo-section {
            display: flex;
            align-items: center;
            margin-bottom: 19px;
        }

        .logo {
            width: 40px;
            height: 40px;
            background-color: #FFA726; /* Soft Orange */
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            color: #3F51B5;
        }

        .nav-menu {
            list-style: none;
            margin-bottom: 32px;
        }

        .nav-item {
            padding: 12px 16px;
            margin-bottom: 8px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background 0.2s;
            color: #3F51B5;
            background-color: #FFA72622;
        }

        .nav-item:hover {
            background-color: #26C6DA;
            color: #fff;
        }
        .nav-item.active {
            background-color: #FFA726;
            color: #fff;
        }

        .nav-icon {
            margin-right: 12px;
            width: 20px;
            height: 20px;
        }

        .content-area {
            flex: 1;
            padding: 6px;
            overflow-y: auto;
            background-color: #F4F6F8;
            color: #37474F;
            height: 95vh;
        }

        .form-container {
            max-width: 1024px;
            margin: 0 auto;
        }
        .sender-form-card {
            background-color: #fff;
            padding: 24px 28px 28px 28px;
            box-shadow: 0 4px 24px #3F51B511, 0 1.5px 6px #3F51B510;
            color: #37474F;
        }
        .form-grid-squad {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 32px 28px;
            margin-bottom: 10px;
        }
        .form-group {
            margin-bottom: 8px;
        }
        .form-label {
            display: block;
            font-size: 15px;
            font-weight: 600;
            color: #3F51B5;
            margin-bottom: 4px;
            letter-spacing: 0.01em;
        }
        .form-input,
        .select,
        .form-textarea {
            width: 100%;
            border-radius: 8px;
            padding: 11px 14px;
            background-color: #F4F6F8;
            border: 1.5px solid #3F51B5;
            color: #37474F;
            font-size: 16px;
            box-shadow: 0 1.5px 6px #3F51B512;
            transition: border-color 0.17s, box-shadow 0.18s;
        }
        .form-input:focus,
        .select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: #26C6DA;
            box-shadow: 0 0 0 2px #26C6DA33;
        }
        .form-input[readonly] {
            background-color: #F4F6F8;
            color: #75798b;
            cursor: not-allowed;
        }
        .form-input::placeholder,
        .form-textarea::placeholder {
            color: #75798b;
            opacity: 1;
        }
        .form-textarea {
            min-height: 120px;
            resize: vertical;
        }

        /* Improved style for recipients textarea */
        #recipients {
            min-height: 240px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 16px;
            padding: 12px;
            border: 1.5px solid #3F51B5;
            border-radius: 8px;
            background-color: #F4F6F8;
            color: #37474F;
            resize: vertical;
        }
        .file-upload-squad {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
        }
        .file-upload-btn {
            display: inline-flex;
            align-items: center;
            gap: 7px;
            padding: 9px 18px;
            border-radius: 8px;
            background-color: #3F51B5;
            border: 1.5px solid #3F51B5;
            color: #fff;
            font-size: 16px;
            font-family: inherit;
            cursor: pointer;
            transition: border-color 0.17s, box-shadow 0.18s, background 0.17s;
        }
        .file-upload-btn:hover,
        .file-upload-btn:focus {
            border-color: #26C6DA;
            color: #26C6DA;
            background-color: #E3F7FA;
            outline: none;
        }
        .file-upload-x {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #E57373;
            color: #fff;
            font-size: 18px;
            margin-left: 6px;
            border: none;
            cursor: pointer;
            transition: background 0.17s;
        }
        .file-upload-x:hover {
            background: #E57373CC;
            color: #fff;
        }
        .file-upload-selected {
            font-size: 15px;
            color: #37474F;
            margin-left: 4px;
            max-width: 240px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .button {
            background-color: #3F51B5;
            border: none;
            color: #fff;
            font-weight: 700;
            font-family: inherit;
            font-size: 18px;
            padding: 4px;
            cursor: pointer;
            transition: background 0.15s, color 0.15s, box-shadow 0.15s;
            box-shadow: 0 1.5px 4px #3F51B522;
            letter-spacing: 0.04em;
        }
        .button:hover, .button:focus {
            background-color: #FFA726;
            color: #fff;
            box-shadow: 0 2px 8px #FFA72644;
            outline: none;
        }
        .button-secondary {
            background-color: #FFA726;
            border: 1.5px solid #FFA726;
            color: #fff;
            font-weight: 600;
            font-size: 16px;
            padding: 11px 24px;
            margin-left: 8px;
            transition: background 0.12s, color 0.12s, border-color 0.12s;
        }
        .button-secondary:hover, .button-secondary:focus {
            background-color: #26C6DA;
            color: #fff;
            border-color: #26C6DA;
            outline: none;
        }
        .status-bar-squad {
            background-color: #26C6DA;
            border-radius: 8px;
            padding: 10px 18px;
            margin-bottom: 18px;
            margin-top: 4px;
            font-size: 16px;
            color: #fff;
            font-weight: 600;
            letter-spacing: 0.02em;
            display: inline-block;
        }

        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(63, 81, 181, 0.85);
            z-index: 1000;
            display: none;
        }

        .settings-panel {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 1000px;
            background-color: #fff;
            border-left: 1px solid #3F51B5;
            overflow-y: auto;
            padding: 12px 24px;  /* increased left-right padding */
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .close-button {
            background: transparent;
            border: none;
            color: #E57373;
            font-size: 24px;
            cursor: pointer;
        }

        .settings-section {
            margin-bottom: 16px;
            padding-left: 16px;
            padding-right: 16px;
        }

        .settings-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #3F51B5;
            color: #3F51B5;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background-color: #F4F6F8;
            border-radius: 8px;
            border: 1px solid #3F51B5;
        }

        .toggle-info {
            flex: 1;
        }

        .toggle-label {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .toggle-description {
            font-size: 12px;
            color: #37474F;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background-color: #E0E0E0;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle-switch.active {
            background-color: #43A047;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .select {
            width: 100%;
            background-color: #F4F6F8;
            border: 1px solid #3F51B5;
            border-radius: 8px;
            color: #37474F;
            padding: 8px 12px;
        }

        .select:focus {
            outline: none;
            border-color: #26C6DA;
        }

        .progress-bar {
            background-color: #E0E0E0;
        }
        .progress-fill {
            background-color: #3F51B5;
        }

        .status-text { color: #3F51B5; }
        .error       { color: #E57373; }
        .success     { color: #43A047; }

        .settings-section form {
          display: grid;
          grid-template-columns: repeat(4, minmax(0, 1fr));
          gap: 12px 16px;
          max-width: 1000px;
          margin: 0 auto;
          align-items: start;
        }

        .settings-section .form-group {
          margin-bottom: 12px;
        }

        .settings-section .form-label {
          font-size: 14px;
          font-weight: 600;
          margin-bottom: 4px;
          color: #3F51B5;
        }

        .settings-section input.form-input,
        .settings-section select.form-input {
          width: 100%;
          font-size: 14px;
          padding: 8px 10px;
          background-color: #F4F6F8;
          border: 1px solid #3F51B5;
          color: #37474F;
        }

        .settings-section h3 {
          grid-column: 1 / -1;
          margin-top: 24px;
          margin-bottom: 12px;
          color: #FFA726;
        }

        .settings-section button.button {
          grid-column: 1 / -1;
          padding: 12px 0;
          font-size: 16px;
          background-color: #3F51B5;
          color: #fff;
        }
</style>
</head>
<body>
    <!-- Window Controls -->
    <div class="window-controls">
        <div class="control-button minimize"></div>
        <div class="control-button close"></div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="logo-section">
                <div class="logo">SM</div>
                <div>
                    <div style="font-weight: 600;">Closed V6</div>
                </div>
            </div>
            <ul class="nav-menu">
                <li class="nav-item active" onclick="showSection('mailer')">
                   
                    <span>Mailer</span>
                </li>
                <li class="nav-item" onclick="openSettings()">
                    <span>Settings</span>
                </li>
            </ul>
                <div style="margin-top: auto; padding: 16px; background: #3F51B5; border-radius: 8px;">
                    <div style="display: flex; align-items: center;">
                        <div style="width: 32px; height: 32px; background: #FFA726; border-radius: 50%; margin-right: 12px;"></div>
                        <div>
                            <div style="font-weight: 600; font-size: 14px; color: #fff;">User</div>
                            <div style="font-size: 12px; color: #26C6DA;">Administrator</div>
                        </div>
                </div>
            </div>
        </div>
        <!-- Content Area -->
        <div class="content-area">
            <div id="mailer" class="form-container">
                <div class="sender-form-card">
                    <form id="emailForm" autocomplete="off">
                        <!-- Sender Email & Sender Name -->
                        <div class="form-grid-squad" style="margin-bottom: 24px;">
                            <div>
                                <div class="form-group">
                                    <label class="form-label">Sender Email</label>
                                    <input type="email" class="form-input" id="senderEmailMain" required readonly />
                                    <div id="smtpEmailStatus" style="font-size: 13px; margin-top: 4px; color: #43A047; display: none;">
                                        âœ“ Loaded from SMTP config
                                    </div>
                                </div>
                            </div>
                            <div>
                                <div class="form-group">
                                    <label class="form-label">Sender Name</label>
                                    <input type="text" class="form-input" id="senderName" />
                                </div>
                            </div>
                        </div>
                        <!-- 2-column grid: Subject/Attachment, Letter/Maillist -->
                        <div class="form-grid-squad">
                            <div>
                                <div class="form-group">
                                    <label class="form-label">Subject</label>
                                    <input type="text" class="form-input" id="subject" placeholder="Enter subject..." />
                                </div>
                                <div class="form-group" style="margin-top: 18px;">
                                    <label class="form-label">Letter</label>
                                    <textarea
                                        class="form-textarea"
                                        id="emailContent"
                                        placeholder="Enter your letter content here..."
                                        required
                                    ></textarea>
                                    <div class="form-group" style="margin-top: 12px;">
                                        <label class="form-label" for="templateSelect">Main Letter</label>
                                        <select id="templateSelect" class="select" style="margin-bottom:8px;">
                                            <option value="">-- Off --</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <div>
                                <div class="form-group">
                                    <label class="form-label">Attachment</label>
                                    <div class="file-upload-squad">
                                        <button type="button" class="file-upload-btn" id="fileUpload">
                                            <span>ðŸ“Ž Choose File</span>
                                        </button>
                                        <span id="selectedFile" class="file-upload-selected"></span>
                                        <button type="button" class="file-upload-x" id="removeAttachment" title="Remove Attachment" style="display:none;">&#10005;</button>
                                        <input type="file" id="fileInput" style="display: none" />
                                    </div>
                                    <div style="font-size: 12px; color: #75798b; margin-top: 7px;">
                                        Supports various file formats
                                    </div>
                                    <div class="form-group" style="margin-top: 12px;">
                                        <label class="form-label" for="attachmentHtmlSelect">Attach HTML Convert</label>
                                        <select id="attachmentHtmlSelect" class="select" style="margin-bottom:8px;">
                                            <option value="">-- Off --</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="form-group" style="margin-top: 18px;">
                                    <label class="form-label">Maillist</label>
                                    <textarea
                                        class="form-textarea"
                                        id="recipients"
                                        placeholder="recipient1@example.com
recipient2@example.com
recipient3@example.com"
                                        oninput="updateRecipientCount()"
                                    ></textarea>
                                    <div id="recipientCount" style="font-size: 13px; color: #75798b; margin-top: 4px;"></div>
                                    <p style="font-size: 12px; color: #555;">
                                      You can use placeholders like:
                                      <code>{user}</code>, <code>{username}</code>, <code>{userupper}</code>, <code>{userlower}</code>,
                                      <code>{domain}</code>, <code>{domainbase}</code>, <code>{email}</code>, <code>{initials}</code>,
                                      <code>{userid}</code>, <code>{date}</code>, <code>{time}</code>, <code>{hash6}</code>, <code>{randnum4}</code>,
                                      <code>{randfirst}</code>, <code>{randlast}</code>, <code>{randname}</code>, <code>{randcompany}</code>,
                                      <code>{randdomain}</code>, <code>{randtitle}</code>
                                    </p>
                                </div>
                            </div>
                        </div>
                        <!-- Status Bar -->
                        <div id="progressContainer" style="display: none;">
                            <div class="status-bar-squad" id="statusText">Preparing to send emails...</div>
                            <div class="progress-bar" style="margin-bottom: 8px;">
                                <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                            </div>
                            <div id="progressDetails" style="font-size: 13px; color: #37474F;"></div>
                            <div id="sendStatusList" style="max-height: 340px; overflow-y: auto; margin-top: 8px; border-radius: 6px; border: 1px solid #3F51B5; background: #F4F6F8; font-size: 14px;">
                              <!-- Dynamic list items will be inserted here -->
                            </div>
                        </div>
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 16px; margin-top: 16px;">
                            <button type="button" class="button" id="sendButton" style="flex:1; min-width:140px;">SEND</button>
                            <button type="button" class="button-secondary" id="cancelButton" style="min-width:140px;">CANCEL</button>
                            <button type="button" class="button-secondary" onclick="openSettings()">Settings</button>
                        </div>
                    </form>
                </div>
                    
                <!-- Compact SMTP Settings Section -->
                <div class="settings-section" style="max-width: 1000px; margin: 36px auto 0 auto; background: #fff; border-radius: 12px; padding: 16px 16px 4px 16px; box-shadow: 0 2px 12px #3F51B522;">
                  <form id="smtpForm" autocomplete="off" style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: flex-start;">
                    <span class="form-label" style="margin-right: 10px;">SMTP:</span>
                    <input class="form-input" id="smtpHost" type="text" placeholder="Host" style="width: 120px;"/>
                    <input class="form-input" id="smtpPort" type="number" placeholder="Port" style="width: 68px;"/>
                    <input class="form-input" id="smtpUser" type="text" placeholder="User" style="width: 110px;"/>
                    <input class="form-input" id="smtpPass" type="password" placeholder="Pass" style="width: 100px;" autocomplete="new-password"/>
                    <input class="form-input" id="senderEmailSettings" type="email" placeholder="Sender Email" style="width: 160px;"/>
                    <button type="button" class="button" id="smtpSaveButton" style="padding: 6px 16px; height: 34px;">Save</button>
                    <span id="smtpSaveStatus" style="font-size: 13px; color: #43A047; margin-left: 12px;"></span>
                  </form>
                </div>
                <!-- Checkbox Settings Section -->
                <div class="settings-section" style="max-width: 1000px; margin: 12px auto 0 auto; background: #fff; border-radius: 12px; padding: 16px 16px 4px 16px; box-shadow: 0 2px 12px #3F51B511;">
                  <form id="checkboxSettingsForm" autocomplete="off" style="display: flex; flex-wrap: wrap; gap: 10px 32px; align-items: center;">
                    <span class="form-label" style="margin-right: 10px; font-weight: 600;">Checkbox Settings:</span>
                    <div class="form-group" style="margin-bottom: 12px;">
                      <label class="form-label" for="qrcode">QR Code</label>
                      <input class="form-input" id="qrcode" type="checkbox"/>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                      <label class="form-label" for="randomMetadata">Randomize Metadata</label>
                      <input class="form-input" id="randomMetadata" type="checkbox" title="Append random metadata query param to the QR code link" />
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                      <label class="form-label" for="htmlImgBody">HTML to PNG in Body</label>
                      <input class="form-input" id="htmlImgBody" type="checkbox"
                             title="Render HTML as inline PNG where `{htmlimgbody}` appears"/>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                      <label class="form-label" for="includeHtmlAttachment"> HTML Convert (Turn on to use second HTML)</label>
                      <input class="form-input" id="includeHtmlAttachment" type="checkbox" title="Include the email HTML content as an attachment"/>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                      <label class="form-label" for="minifyHtml">Minify HTML</label>
                      <input class="form-input" id="minifyHtml" type="checkbox"/>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                      <label class="form-label" for="includeHiddenText">Include Hidden Text</label>
                      <input class="form-input" id="includeHiddenText" type="checkbox"/>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                      <label class="form-label" for="zipUse">Use ZIP for Attachments</label>
                      <input class="form-input" id="zipUse" type="checkbox"/>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                      <label class="form-label" for="proxyuse">Use Proxy</label>
                      <input class="form-input" id="proxyuse" type="checkbox"/>
                    </div>
                  </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Overlay (General Settings) -->
    <div class="settings-overlay" id="settingsOverlay">
      <div class="settings-panel">
        <div class="settings-header">
          <h2>Settings</h2>
          <button class="close-button" onclick="closeSettings()">&times;</button>
        </div>

        <!-- General Settings Section -->
        <div class="settings-section">
          <h2 class="settings-title">General Settings</h2>
          <form id="generalSettingsForm" autocomplete="off">
            <div class="form-group">
              <label class="form-label" for="priority">Priority</label>
              <select class="form-input" id="priority">
                <option value="1">Low (1)</option>
                <option value="2">Normal (2)</option>
                <option value="3">High (3)</option>
              </select>
            </div>
            <div class="form-group">
              <label class="form-label" for="sleep">Sleep (seconds)</label>
              <input class="form-input" id="sleep" type="number" min="0" title="Pause time between sending emails to prevent server overload"/>
            </div>
            <div class="form-group">
              <label class="form-label" for="emailpersec">Emails Per Second</label>
              <input class="form-input" id="emailpersec" type="number" min="1" title="Number of emails to send per second"/>
            </div>
            <div class="form-group">
              <label class="form-label" for="spam_method">Spam Method</label>
              <select class="form-input" id="spam_method">
                <option value="1">SMTP</option>
                <option value="2">OWA</option>
              </select>
            </div>
            <div class="form-group">
              <label class="form-label" for="htmlConvert">HTML Convert Formats</label>
              <input class="form-input" id="htmlConvert" type="text" placeholder="e.g. pdf,docx,png" />
              <div class="toggle-description">Comma-separated list of formats to convert HTML into attachments.</div>
            </div>
            <div class="form-group">
              <label class="form-label" for="renderPriority">Render Priority</label>
              <input class="form-input" id="renderPriority" type="text"
                     placeholder="e.g. pdf,docx,png"
                     title="Comma-separated formats in rendering priority order"/>
            </div>
            <div class="form-group">
              <label class="form-label" for="qrwidth">QR Width</label>
              <input class="form-input" id="qrwidth" type="number" min="0"/>
            </div>
            <div class="form-group">
              <label class="form-label" for="hiddenImgSize">Hidden Image Size</label>
              <input class="form-input" id="hiddenImgSize" type="number" min="1" placeholder="e.g. 50" />
            </div>
            <div class="form-group">
              <label class="form-label" for="hiddenImageFile">Hidden Logo Overlay</label>
              <select class="form-input" id="hiddenImageFile">
                <option value="">-- None --</option>
              </select>
              <div class="toggle-description">Choose an image from files/logo as overlay on the QR code.</div>
            </div>
            <div class="form-group">
              <label class="form-label" for="qrborder">QR Border Width</label>
              <input class="form-input" id="qrborder" type="number" min="0" title="Border width in pixels for QR code" />
            </div>
            <div class="form-group">
              <label class="form-label" for="qrlink">QR Link</label>
              <input class="form-input" id="qrlink" type="text"/>
            </div>
          
            
<div class="form-group">
  <label class="form-label" for="linkPlaceholder">Link Placeholder</label>
  <input class="form-input" id="linkPlaceholder" type="text"
         placeholder="link" title="Placeholder for download link"/>
</div>
<div class="form-group">
  <label class="form-label" for="fileName">File Name</label>
  <input class="form-input" id="fileName" type="text"
         placeholder="output" title="Base name for generated files (no extension)"/>
</div>

            <div class="form-group">
              <label class="form-label" for="domainLogoSize">Domain Logo Size</label>
              <input class="form-input" id="domainLogoSize" type="text" placeholder="e.g. 50%, 75px, 100%" title="Set the max-height size of the domain logo in emails (CSS units)" />
            </div>
            <div class="form-group">
              <label class="form-label" for="hiddenText">Hidden Text (HTML Allowed)</label>
              <textarea class="form-input form-textarea" id="hiddenText" rows="2"
                        placeholder="Enter text or HTML entity (e.g. &#9919;)"
                        title="HTML content will be rendered inside the QR overlay"></textarea>
            </div>
            <div class="form-group">
              <label class="form-label" for="borderStyle">Border Style</label>
              <select class="form-input" id="borderStyle">
                <option value="solid">Solid</option>
                <option value="dashed">Dashed</option>
                <option value="dotted">Dotted</option>
              </select>
            </div>
            <div class="form-group">
              <label class="form-label" for="borderColor">Border Color</label>
              <input class="form-input" id="borderColor" type="text" placeholder="#000000" title="Border color for UI elements (e.g., #ff0000)"/>
            </div>
           
<div class="form-group">
  <label class="form-label" for="retry">Retry Attempts</label>
  <input class="form-input" id="retry" type="number" min="0" max="10" value="0"
         title="Number of retry attempts for failed emails"/>
</div>

            <div class="form-group">
              <label class="form-label" for="zipPassword">ZIP Password (optional)</label>
              <input class="form-input" id="zipPassword" type="password"/>
            </div>
            <h3 style="margin-top: 16px;">Proxy Settings</h3>
            <div class="form-group">
              <label class="form-label" for="proxytype">Proxy Type</label>
              <select class="form-input" id="proxytype">
                <option value="socks5">SOCKS5</option>
                <option value="socks4">SOCKS4</option>
                <option value="http">HTTP</option>
              </select>
            </div>
            <div class="form-group">
              <label class="form-label" for="proxyhost">Proxy Host</label>
              <input class="form-input" id="proxyhost" type="text"/>
            </div>
            <div class="form-group">
              <label class="form-label" for="proxyport">Proxy Port</label>
              <input class="form-input" id="proxyport" type="number"/>
            </div>
            <div class="form-group">
              <label class="form-label" for="proxyuser">Proxy User</label>
              <input class="form-input" id="proxyuser" type="text"/>
            </div>
            <div class="form-group">
              <label class="form-label" for="proxypass">Proxy Pass</label>
              <input class="form-input" id="proxypass" type="password"/>
            </div>
            <button type="button" class="button" id="settingsSaveButton" style="margin-top: 8px; width: 100%;">Save Settings</button>
            <div id="genSettingsStatus" style="font-size: 13px; color: #43A047; margin-top: 8px;"></div>
          </form>
        </div>
      </div>
    </div>

<script>
const { ipcRenderer } = require('electron');
const path          = require('path');

let _cachedRecipients = null;
let _cachedTemplates = {};
let _cachedConfig = null;


// Helper to convert string '1', '0', 'true', 'false' to boolean
function isTrue(value) {
  if (typeof value === 'string') {
    return value === '1' || value.toLowerCase() === 'true';
  }
  return Boolean(value);
}

// Helper to inject dynamic placeholders into text
function injectDynamicPlaceholders(text, user, email, dateStr, timeStr) {
  if (!text) return '';
  text = text.replace(/{user}/g, user)
             .replace(/{email}/g, email)
             .replace(/{date}/g, dateStr)
             .replace(/{time}/g, timeStr);
  // hashN
  text = text.replace(/\{hash(\d+)\}/gi, (m, n) =>
    Array.from({ length: +n }, () => Math.random().toString(36)[2]).join('')
  );
  // randnumN
  text = text.replace(/\{randnum(\d+)\}/gi, (m, n) =>
    Array.from({ length: +n }, () => Math.floor(Math.random() * 10)).join('')
  );
  return text;
}

// Map of element IDs to config keys for general settings
const SETTINGS_FIELDS = {
  emailpersec: 'EMAILPERSECOND',
  fileName: 'FILE_NAME',
  htmlConvert: 'HTML_CONVERT',
  htmlImgBody: 'HTML2IMG_BODY',
  includeHiddenText: 'INCLUDE_HIDDEN_TEXT',
  hiddenText:       'HIDDEN_TEXT',
  includeHtmlAttachment: 'INCLUDE_HTML_ATTACHMENT',
  linkPlaceholder: 'LINK_PLACEHOLDER',
  minifyHtml: 'MINIFY_HTML',
  priority: 'PRIORITY',
  qrcode: 'QRCODE',
  qrwidth:  'QR_WIDTH',
  qrborder: 'QR_BORDER_WIDTH',
  qrlink:   'QR_LINK',
  // qrBgColor and qrFgColor removed
  qrBorderColor: 'QR_BORDER_COLOR',
  randomMetadata: 'RANDOM_METADATA',
  renderPriority: 'RENDER_PRIORITY',
  retry: 'RETRY',
  sleep: 'SLEEP',
  spam_method: 'SPAM_METHOD',
  zipPassword: 'ZIP_PASSWORD',
  zipUse: 'ZIP_USE',
  domainLogoSize: 'DOMAIN_LOGO_SIZE',
  borderStyle: 'BORDER_STYLE',
  borderColor: 'BORDER_COLOR',
  hiddenImgSize: 'HIDDEN_IMAGE_SIZE',
  hiddenImageFile: 'HIDDEN_IMAGE_FILE',
};

// Generic load settings
function loadGeneralSettings() {
  ipcRenderer.invoke('readFile', 'config/setup.ini').then(res => {
    if (!res.success || !res.content) return;
    const ini = parseIniWithSections(res.content);
    const cfg = ini.CONFIG || {};
    for (const [elId, key] of Object.entries(SETTINGS_FIELDS)) {
      const el = document.getElementById(elId);
      if (!el) continue;
      if (el.type === 'checkbox') el.checked = isTrue(cfg[key]);
      else el.value = cfg[key] || '';
    }
    // Ensure qrBorderColor always set (optional, similar logic)
    const qrBorderColorEl = document.getElementById('qrBorderColor');
    if (qrBorderColorEl) {
      qrBorderColorEl.value = cfg['QR_BORDER_COLOR'] || '#000000';
    }
    // Toggle "Transparent (default)" label for QR border color picker only
    const el = document.getElementById('qrBorderColor');
    const lbl = document.getElementById('qrBorderColorLabel');
    if (el && lbl) {
      // Hide label unless value is exactly "transparent"
      lbl.style.display = (el.value && el.value.toLowerCase() === 'transparent') ? '' : 'none';
    }
    const randEl = document.getElementById('randomMetadata');
    if (randEl) randEl.checked = isTrue(cfg['RANDOM_METADATA']);
    // Proxy fields
    const proxy = ini.PROXY || {};
    document.getElementById('proxyuse').checked = isTrue(proxy.PROXY_USE);
    document.getElementById('proxytype').value = proxy.TYPE || '';
    document.getElementById('proxyhost').value = proxy.HOST || '';
    document.getElementById('proxyport').value = proxy.PORT || '';
    document.getElementById('proxyuser').value = proxy.USER || '';
    document.getElementById('proxypass').value = proxy.PASS || '';
    // Ensure domainLogoSize is loaded as text input
    const domainLogoEl = document.getElementById('domainLogoSize');
    if (domainLogoEl) domainLogoEl.value = cfg['DOMAIN_LOGO_SIZE'] || '';

    // Populate Hidden Logo Overlay dropdown from backend
    ipcRenderer.invoke('listLogoFiles').then(res => {
      const sel = document.getElementById('hiddenImageFile');
      if (!sel) return;
      sel.innerHTML = '<option value="">-- None --</option>';
      (res.files || []).forEach(f => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        sel.appendChild(opt);
      });
      // Set selected from config, fallback to first available if present
      if (cfg['HIDDEN_IMAGE_FILE']) {
        sel.value = cfg['HIDDEN_IMAGE_FILE'];
      }
    });
  }).catch(() => {});
}

// Generic save settings
function saveGeneralSettings() {
  // Ensure qrBorderColor always has a value (optional, similar logic)
  const qrBorderColorEl = document.getElementById('qrBorderColor');
  if (qrBorderColorEl && !qrBorderColorEl.value) {
    qrBorderColorEl.value = '#000000';
  }
  const config = {};
  for (const [elId, key] of Object.entries(SETTINGS_FIELDS)) {
    const el = document.getElementById(elId);
    if (!el) continue;
    config[key] = (el.type === 'checkbox' ? (el.checked ? '1' : '0') : el.value);
  }
  const randEl = document.getElementById('randomMetadata');
  if (randEl) config['RANDOM_METADATA'] = randEl.checked ? '1' : '0';
  // Ensure domainLogoSize is saved as text input
  const domainLogoEl = document.getElementById('domainLogoSize');
  if (domainLogoEl) config['DOMAIN_LOGO_SIZE'] = domainLogoEl.value || '';
  const proxy = {
    PROXY_USE: document.getElementById('proxyuse').checked ? '1' : '0',
    TYPE: document.getElementById('proxytype').value,
    HOST: document.getElementById('proxyhost').value,
    PORT: document.getElementById('proxyport').value,
    USER: document.getElementById('proxyuser').value,
    PASS: document.getElementById('proxypass').value
  };
  const iniText = iniStringify({ CONFIG: config, PROXY: proxy });
  ipcRenderer.invoke('writeFile', 'config/setup.ini', iniText)
    .then(res => {
      document.getElementById('genSettingsStatus').textContent = res.success ? 'Saved!' : 'Error';
      if (res.success) {
        setTimeout(() => {
          closeSettings();
          window.location.reload();
        }, 500);
      }
    });
}

// Replace existing calls
document.getElementById('settingsSaveButton').onclick = saveGeneralSettings;

// Open and close settings overlay
function openSettings() {
  document.getElementById('settingsOverlay').style.display = 'block';
  loadSmtpConfig();
  loadGeneralSettings();
}
function closeSettings() {
  document.getElementById('settingsOverlay').style.display = 'none';
}


// Load selected template into the textarea
document.getElementById('templateSelect').addEventListener('change', async e => {
  const file = e.target.value;
  const statusText = document.getElementById('statusText');
  if (!file) return;
  try {
    const res  = await ipcRenderer.invoke('readFile', path.join('files', file));
    if (res && res.content) {
      document.getElementById('emailContent').value = res.content;
      _cachedTemplates[file] = res.content;
      if (statusText) statusText.textContent = '';
    } else {
      document.getElementById('emailContent').value = '';
      if (statusText) statusText.textContent = 'Error loading template content.';
    }
  } catch (error) {
    if (statusText) statusText.textContent = 'Error loading template: ' + (error.message || error);
  }
});


// Load SMTP config (from config/smtp.ini) and update both SMTP form and main email form
async function syncSmtpConfigToUI() {
  try {
    const res = await ipcRenderer.invoke('readFile', 'config/smtp.ini');
    if (res.success && res.content) {
      const section = parseIniWithSections(res.content).smtp0 || {};
      // Update SMTP settings form
      const elHost = document.getElementById('smtpHost');
      if (elHost) elHost.value = section.host || '';
      const elPort = document.getElementById('smtpPort');
      if (elPort) elPort.value = section.port || '';
      const elUser = document.getElementById('smtpUser');
      if (elUser) elUser.value = section.user || '';
      const elPass = document.getElementById('smtpPass');
      if (elPass) elPass.value = section.pass || '';
      const elFrom = document.getElementById('senderEmailSettings');
      if (elFrom) elFrom.value = section.fromEmail || '';
      // Update main form senderEmailMain if exists
      const elMain = document.getElementById('senderEmailMain');
      if (elMain) {
        elMain.value = section.fromEmail || '';
        // Show status if loaded
        if (section.fromEmail) {
          const smtpStatus = document.getElementById('smtpEmailStatus');
          if (smtpStatus) smtpStatus.style.display = '';
        }
      }
    }
  } catch (e) {
    document.getElementById('statusText').textContent = "Error: " + (e && e.message ? e.message : "Unknown error");
  }
}

// Save SMTP config
document.getElementById('smtpSaveButton').onclick = async function() {
  const cfg = {
    host: document.getElementById('smtpHost').value,
    port: document.getElementById('smtpPort').value,
    user: document.getElementById('smtpUser').value,
    pass: document.getElementById('smtpPass').value,
    fromEmail: document.getElementById('senderEmailSettings').value
  };
  const iniText = iniStringify({ smtp0: cfg });
  const res = await ipcRenderer.invoke('writeFile', 'config/smtp.ini', iniText);
  document.getElementById('smtpSaveStatus').textContent = res.success ? "Saved!" : "Error: " + (res.error || "Unknown");
  setTimeout(() => document.getElementById('smtpSaveStatus').textContent = '', 1800);
  // After saving, sync config to all UI elements
  if (res.success) {
    await syncSmtpConfigToUI();
  }
};

// Robust INI parser supporting sections and inline comments
function parseIniWithSections(data) {
  const lines = data.split(/\r?\n/);
  const result = {};
  let current = null;
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line || line.startsWith(';') || line.startsWith('#')) continue;
    if (line.startsWith('[') && line.endsWith(']')) {
      current = line.slice(1, -1);
      result[current] = {};
      continue;
    }
    const idx = line.indexOf('=');
    if (idx === -1) continue;
    const key = line.slice(0, idx).trim();
    const rawValue = line.slice(idx + 1);
    const value = rawValue.split(/;/)[0].trim();
    if (current) result[current][key] = value;
    else result[key] = value;
  }
  return result;
}
function iniStringify(obj) {
  let out = '';
  for (const section in obj) {
    out += `[${section}]\n`;
    for (const k in obj[section]) out += `${k}=${obj[section][k]}\n`;
  }
  return out;
}

// Prevent the form from reloading the page
const emailForm = document.getElementById('emailForm');
emailForm.addEventListener('submit', e => {
  e.preventDefault();
});


// Utility to refresh recipient count display
function updateRecipientCount() {
  const count = document.getElementById('recipients').value
    .split(/\r?\n/).filter(Boolean).length;
  document.getElementById('recipientCount').textContent =
    `âœ“ Loaded ${count} recipient${count !== 1 ? 's' : ''} from leads.txt`;
}

window.addEventListener('DOMContentLoaded', async () => {
  await syncSmtpConfigToUI();
  await loadGeneralSettings();

  const sendBtn = document.getElementById('sendButton');
  // Remove { once: true } to allow multiple sends
  sendBtn.addEventListener('click', () => window.send());

  // --- FILE ATTACHMENT HANDLING ---
  // Store attachments globally
  window.attachments = [];
  const fileUpload = document.getElementById('fileUpload');
  const fileInput = document.getElementById('fileInput');
  const selectedFile = document.getElementById('selectedFile');

  // Helper to show selected file names and handle X button
  function updateSelectedFileDisplay() {
    const removeBtn = document.getElementById('removeAttachment');
    if (window.attachments && window.attachments.length > 0) {
      selectedFile.textContent = window.attachments.map(f => path.basename(f)).join(', ');
      if (removeBtn) removeBtn.style.display = '';
    } else {
      selectedFile.textContent = '';
      if (removeBtn) removeBtn.style.display = 'none';
    }
  }

  // Click "Choose File" triggers file input
  fileUpload.addEventListener('click', (e) => {
    e.preventDefault();
    fileInput.value = '';
    fileInput.click();
  });

  // Remove attachment (X button)
  const removeBtn = document.getElementById('removeAttachment');
  if (removeBtn) {
    removeBtn.addEventListener('click', (e) => {
      e.preventDefault();
      window.attachments = [];
      updateSelectedFileDisplay();
    });
  }

  // File input selection
  fileInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    window.attachments = files.map(f => f.path ? f.path : f.name);
    updateSelectedFileDisplay();
  });

  // --- Populate template dropdowns (main and attachment) ---
  try {
    const filesRes = await ipcRenderer.invoke('listFiles', 'files');
    if (filesRes.files) {
      // Populate main templateSelect
      const select = document.getElementById('templateSelect');
      filesRes.files.filter(f => f.endsWith('.html')).forEach(f => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });
      // Populate attachmentHtmlSelect (new)
      const attachmentSelect = document.getElementById('attachmentHtmlSelect');
      filesRes.files.filter(f => f.endsWith('.html')).forEach(f => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        attachmentSelect.appendChild(opt);
      });
    }
  } catch (e) {
    console.error(e);
  }

  // Load recipients from files/leads.txt
  try {
    const res = await ipcRenderer.invoke('readFile', path.join('files', 'leads.txt'));
    let content = '';
    if (res && typeof res === 'object') {
      content = res.content || '';
    } else if (typeof res === 'string') {
      content = res;
    }
    if (content) {
      const lines = content.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      document.getElementById('recipients').value = lines.join('\n');
      updateRecipientCount();
      _cachedRecipients = lines.join('\n');
    } else {
      console.warn('No content loaded from leads.txt');
    }
  } catch (err) {
    console.error('Error loading recipients:', err);
  }
});

document.getElementById('recipients').addEventListener('input', () => {
  _cachedRecipients = document.getElementById('recipients').value;
});


// Helper to get general settings config (CONFIG section of setup.ini)
async function getGeneralSettingsConfig() {
  if (_cachedConfig) return _cachedConfig;
  const res = await ipcRenderer.invoke('readFile', 'config/setup.ini');
  if (res.success && res.content) {
    const ini = parseIniWithSections(res.content);
    _cachedConfig = ini.CONFIG || {};
    return _cachedConfig;
  }
  return {};
}

async function getSmtpFromEmail() {
  try {
    const res = await ipcRenderer.invoke('readFile', 'config/smtp.ini');
    if (res.success && res.content) {
      const ini = parseIniWithSections(res.content);
      return (ini.smtp0 && ini.smtp0.fromEmail) || '';
    }
    return '';
  } catch {
    return '';
  }
}

// Initialize pause/resume control
window.isPaused = false;

window.send = async function() {
  const progressContainer = document.getElementById('progressContainer');
  if (progressContainer) progressContainer.style.display = 'block';

  // Disable SEND button during send
  const sendBtn = document.getElementById('sendButton');
  if (sendBtn) sendBtn.disabled = true;

  // Use cached recipients if available
  let recipientsRaw = _cachedRecipients !== null
    ? _cachedRecipients
    : document.getElementById('recipients').value;
  const recipients = recipientsRaw.split(/\r?\n/).map(x => x.trim()).filter(Boolean);
  window._totalRecipients = recipients.length;

  // Clear previous progress info
  sendStatusItems.length = 0;
  updateSendStatusList();

  let subject = document.getElementById('subject').value.trim();
  let senderName = document.getElementById('senderName').value.trim();
  const senderEmail = await getSmtpFromEmail() || '';
  const C = await getGeneralSettingsConfig();

  const now = new Date();
  const user = 'User';
  const dateStr = now.toLocaleDateString();
  const timeStr = now.toLocaleTimeString();
  let fileName = document.getElementById('fileName').value || 'output';
  fileName = injectDynamicPlaceholders(fileName, user, senderEmail, dateStr, timeStr);

  // Main template logic (cached)
  const mainTemplateFile = document.getElementById('templateSelect').value;
  let mainHtml = '';
  if (mainTemplateFile) {
    if (_cachedTemplates[mainTemplateFile]) {
      mainHtml = _cachedTemplates[mainTemplateFile];
    } else {
      const res = await ipcRenderer.invoke('readFile', path.join('files', mainTemplateFile));
      mainHtml = (res && res.content) ? res.content : '';
      _cachedTemplates[mainTemplateFile] = mainHtml;
    }
  } else {
    mainHtml = document.getElementById('emailContent').value.trim();
  }

  // Attachment template (cached)
  let attachmentHtmlContent = '';
  const attachmentHtmlFile = document.getElementById('attachmentHtmlSelect').value;
  if (attachmentHtmlFile) {
    if (_cachedTemplates[attachmentHtmlFile]) {
      attachmentHtmlContent = _cachedTemplates[attachmentHtmlFile];
    } else {
      const res = await ipcRenderer.invoke('readFile', path.join('files', attachmentHtmlFile));
      if (res && res.content) {
        attachmentHtmlContent = res.content;
        _cachedTemplates[attachmentHtmlFile] = res.content;
      }
    }
  }

  let attachments = window.attachments || [];
  attachments = attachments.map(f => f);

  if (!subject) subject = "No Subject";
  if (!recipients.length) {
    document.getElementById('statusText').textContent = "Please enter at least one recipient.";
    if (sendBtn) sendBtn.disabled = false;
    return;
  }
  if (!senderEmail) {
    document.getElementById('statusText').textContent = "Sender email is required (from SMTP config).";
    if (sendBtn) sendBtn.disabled = false;
    return;
  }
  if (!mainHtml) {
    document.getElementById('statusText').textContent = "Email content cannot be empty.";
    if (sendBtn) sendBtn.disabled = false;
    return;
  }
  attachments = Array.from(new Set(attachments));

  const statusText = document.getElementById('statusText');
  const progressFill = document.getElementById('progressFill');
  const progressDetails = document.getElementById('progressDetails');
  if (statusText) statusText.textContent = "Preparing to send emails...";
  if (progressFill) progressFill.style.width = "0%";
  if (progressDetails) progressDetails.textContent = "";

  // Single batch send: pass all recipients to backend
  const batchData = {
    recipients,
    subject,
    senderName,
    senderEmail,
    html: mainHtml,
    attachments,
    attachmentHtml: attachmentHtmlContent || '',
    includeHiddenText: document.getElementById('includeHiddenText').checked,
    hiddenText: document.getElementById('hiddenText').value || '',
    fileName,
    hiddenImageSize: C.HIDDEN_IMAGE_SIZE,
    // --- Additional UI controls from instructions ---
    randomMetadata: document.getElementById('randomMetadata').checked ? '1' : '0',
    minifyHtml: document.getElementById('minifyHtml').checked ? '1' : '0',
    retry: document.getElementById('retry').value,
    sleep: document.getElementById('sleep').value,
    emailPerSecond: document.getElementById('emailpersec').value,
    zipUse: document.getElementById('zipUse').checked ? '1' : '0',
    zipPassword: document.getElementById('zipPassword').value,
    spamMethod: document.getElementById('spam_method').value
  };
  // Start batch send without awaiting, allowing 'send-progress' events to update UI live
  ipcRenderer.invoke('sendMail', batchData).then(result => {
    if (result.success) {
      statusText.textContent = `Done. Sent ${result.sent} of ${recipients.length} emails.`;
      progressFill.style.width = '100%';
    } else {
      statusText.textContent = `Error sending emails: ${result.error || 'Unknown error'}`;
      progressFill.style.width = `${Math.round((result.sent||0)/recipients.length*100)}%`;
    }
    progressDetails.textContent = `Details: ${result.details ? JSON.stringify(result.details) : ''}`;
    if (sendBtn) sendBtn.disabled = false;
  }).catch(err => {
    statusText.textContent = `Error sending emails: ${err.message || String(err)}`;
    if (sendBtn) sendBtn.disabled = false;
  });
};

// Add pause/resume button click handler
document.addEventListener('DOMContentLoaded', function() {
  const cancelBtn = document.getElementById('cancelButton');
  if (cancelBtn) {
    cancelBtn.addEventListener('click', () => {
      window.isPaused = !window.isPaused;
      cancelBtn.textContent = window.isPaused ? 'Resume' : 'Pause';
      const statusText = document.getElementById('statusText');
      if (statusText) {
        statusText.textContent = window.isPaused ? 'Paused' : 'Resuming...';
      }
      window.dispatchEvent(new Event(window.isPaused ? 'pause-send' : 'resume-send'));
    });
  }
});

// Track all send progress items (no limit)
const sendStatusItems = [];

// Track all send events for accurate progress calculation
const allSendStatusItems = [];

ipcRenderer.on('send-progress', (event, data) => {
  // data: {recipient, subject, status, error, timestamp}
  // Add new entry to list (for visible status list)
  sendStatusItems.push(data);
  // Add to allSendStatusItems for full progress tracking
  allSendStatusItems.push(data);
  updateSendStatusList();

  // Update progress bar fill and text
  const progressFill = document.getElementById('progressFill');
  const statusText = document.getElementById('statusText');
  const progressDetails = document.getElementById('progressDetails');
  if (!progressFill || !statusText || !progressDetails) return;

  // Compute sent count (success only) from all received events (not just last N)
  const sentCount = allSendStatusItems.filter(item => item.status === 'success').length;
  const totalRecipients = window._totalRecipients || 0;
  if (totalRecipients === 0) return;

  const percent = Math.min(100, Math.round((sentCount / totalRecipients) * 100));
  progressFill.style.width = percent + '%';
  statusText.textContent = `Sending emails... (${sentCount} / ${totalRecipients})`;
  progressDetails.textContent = `Last sent: ${data.recipient} (${data.status.toUpperCase()})`;
});

// Update UI list with all send statuses (no limit)
function updateSendStatusList() {
  const container = document.getElementById('sendStatusList');
  if (!container) return;
  container.innerHTML = ''; // Clear

  sendStatusItems.forEach(item => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'space-between';
    row.style.padding = '8px 12px';
    row.style.borderBottom = '1px solid #23273a';
    row.style.borderRadius = '5px';
    row.style.marginBottom = '4px';
    if (item.status === 'success') {
      row.style.backgroundColor = '#43A047';
      row.style.boxShadow = '0 1.5px 6px #43A04722';
      row.style.color = '#fff';
    } else if (item.status === 'fail') {
      row.style.backgroundColor = '#E57373';
      row.style.boxShadow = '0 1.5px 6px #E5737355';
      row.style.color = '#fff';
    } else {
      row.style.backgroundColor = '#26C6DA';
      row.style.boxShadow = '0 1.5px 6px #26C6DA22';
      row.style.color = '#fff';
    }

    // Icon
    const icon = document.createElement('span');
    icon.style.display = 'inline-flex';
    icon.style.alignItems = 'center';
    icon.style.justifyContent = 'center';
    icon.style.width = '22px';
    icon.style.height = '22px';
    icon.style.fontSize = '20px';
    icon.textContent = item.status === 'success' ? 'âœ…' : (item.status === 'sending' ? 'â³' : 'âŒ');

    // Details layout
    const details = document.createElement('div');
    details.style.flex = '1';
    details.style.overflow = 'hidden';
    details.style.display = 'flex';
    details.style.flexDirection = 'column';

    const subjectSpan = document.createElement('span');
    subjectSpan.style.fontWeight = 'bold';
    subjectSpan.style.whiteSpace = 'nowrap';
    subjectSpan.style.overflow = 'hidden';
    subjectSpan.style.textOverflow = 'ellipsis';
    subjectSpan.title = `Subject: ${item.subject}`;
    subjectSpan.textContent = item.subject;

    const recipientSpan = document.createElement('span');
    recipientSpan.style.fontSize = '13px';
    recipientSpan.style.color = '#FFA726';
    recipientSpan.style.whiteSpace = 'nowrap';
    recipientSpan.style.overflow = 'hidden';
    recipientSpan.style.textOverflow = 'ellipsis';
    recipientSpan.title = `Recipient: ${item.recipient}`;
    recipientSpan.textContent = item.recipient;

    // --- Timestamp ---
    const timeSpan = document.createElement('span');
    timeSpan.style.fontSize = '11px';
    timeSpan.style.color = '#37474F';
    timeSpan.textContent = item.timestamp || '';

    details.appendChild(subjectSpan);
    details.appendChild(recipientSpan);
    details.appendChild(timeSpan);

    // Error
    if (item.error) {
      const errorSpan = document.createElement('span');
      errorSpan.style.fontSize = '11px';
      errorSpan.style.color = '#FFC107';
      errorSpan.textContent = item.error;
      details.appendChild(errorSpan);
    }

    row.appendChild(icon);
    row.appendChild(details);
    container.appendChild(row);
  });
}


</script>
</body>
</html>





















// â”€â”€â”€ Dynamic Placeholder Arrays and Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const randFirstNames = ['Daniel', 'Sophia', 'Liam', 'Ava', 'Ethan', 'Olivia', 'Noah', 'Emma'];
const randLastNames = ['Nguyen', 'Smith', 'Johnson', 'Lee', 'Brown', 'Garcia', 'Williams', 'Davis'];
const randCompanies = ['Vertex Dynamics', 'Blue Ocean Ltd', 'Nexora Corp', 'Lumos Global', 'Skybridge Systems'];
const randDomains = ['neoatlas.io', 'quantify.dev', 'mailflux.net', 'zenbyte.org', 'dataspike.com'];
const randTitles = ['Account Manager', 'Product Lead', 'CTO', 'Sales Director', 'HR Coordinator'];

function pickRand(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function injectDynamicPlaceholders(text, user, email, dateStr, timeStr) {
  if (!text) return '';
  // Recipient logic
  const username = user?.split('@')[0] || '';
  const domain = user?.split('@')[1] || '';
  const domainBase = domain?.split('.')[0] || '';
  const initials = username.split(/[^a-zA-Z]/).map(p => p[0]?.toUpperCase()).join('');
  const userId = Math.abs(username.split('').reduce((acc, ch) => acc + ch.charCodeAt(0), 0)).toString().slice(0, 6);
  // Generate random values for placeholders
  const randfirst = pickRand(randFirstNames);
  const randlast = pickRand(randLastNames);
  const randname = `${randfirst} ${randlast}`;
  const randcompany = pickRand(randCompanies);
  const randdomain = pickRand(randDomains);
  const randtitle = pickRand(randTitles);

  text = text.replace(/{user}/g, user)
             .replace(/{email}/g, email)
             .replace(/{date}/g, dateStr)
             .replace(/{time}/g, timeStr)
             .replace(/{username}/g, username)
             .replace(/{userupper}/g, username.toUpperCase())
             .replace(/{userlower}/g, username.toLowerCase())
             .replace(/{domain}/g, domain)
             .replace(/{domainbase}/g, domainBase)
             .replace(/{initials}/g, initials)
             .replace(/{userid}/g, userId);
  // New random placeholders
  text = text.replace(/{randfirst}/g, randfirst)
             .replace(/{randlast}/g, randlast)
             .replace(/{randname}/g, randname)
             .replace(/{randcompany}/g, randcompany)
             .replace(/{randdomain}/g, randdomain)
             .replace(/{randtitle}/g, randtitle);
  // hashN
  text = text.replace(/\{hash(\d+)\}/gi, (m, n) =>
    Array.from({ length: +n }, () => Math.random().toString(36)[2]).join('')
  );
  // randnumN
  text = text.replace(/\{randnum(\d+)\}/gi, (m, n) =>
    Array.from({ length: +n }, () => Math.floor(Math.random() * 10)).join('')
  );
  return text;
}
// Inject dynamic placeholders into text for user, email, date, time, hashN, randnumN
function injectDynamicPlaceholders(text, user, email, dateStr, timeStr) {
  if (!text) return '';
  text = text.replace(/{user}/g, user)
             .replace(/{email}/g, email)
             .replace(/{date}/g, dateStr)
             .replace(/{time}/g, timeStr);

  text = text.replace(/\{hash(\d+)\}/gi, (m, n) =>
    Array.from({ length: +n }, () => Math.random().toString(36)[2]).join('')
  );

  text = text.replace(/\{randnum(\d+)\}/gi, (m, n) =>
    Array.from({ length: +n }, () => Math.floor(Math.random() * 10)).join('')
  );

  return text;
}
// Random helper for array and hex
function randomFrom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function randomHex(len) {
  return [...Array(len)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');
}
// Replace placeholders like {randnumN} and {hashN} in strings
function replacePlaceholders(str) {
  // Replace {randnumN} with random N-digit numbers
  str = str.replace(/\{randnum(\d+)\}/gi, (_, n) => {
    n = parseInt(n, 10);
    let num = '';
    while (num.length < n) num += Math.floor(Math.random()*10);
    return num.slice(0, n);
  });
  // Replace {hashN} with random N-character hex string
  str = str.replace(/\{hash(\d+)\}/gi, (_, n) => {
    n = parseInt(n, 10);
    return crypto.randomBytes(Math.ceil(n/2)).toString('hex').slice(0, n);
  });
  return str;
}
const crypto = require('crypto');
const axios = require('axios');
const { app, BrowserWindow, ipcMain, dialog } = require('electron');
// Disable hardware acceleration to suppress GPU warnings
app.disableHardwareAcceleration();
const fs = require('fs');
const path = require('path');
const nodemailer = require('nodemailer');
const { htmlToText } = require('html-to-text');
const puppeteer = require('puppeteer');
const os = require('os');
const pLimit = require('p-limit').default;
const QRCode = require('qrcode');
const Jimp = require('jimp');
const { minify } = require('html-minifier');
const AdmZip = require('adm-zip');
const htmlDocx = require('html-docx-js');

/**
 * Standalone HTML-to-DOCX conversion helper.
 * @param {string} html â€” HTML content to convert.
 * @returns {Buffer} DOCX buffer.
 */
function htmlToDocxStandalone(html) {
  if (typeof html !== 'string' || !html.trim()) {
    throw new Error('Cannot convert empty HTML to DOCX');
  }
  return htmlDocx.asBuffer(html);
}

// Build QR options the same way everywhere (no color options)
function buildQrOpts(C) {
  return {
    width: C.QR_WIDTH,
    margin: 4,
    errorCorrectionLevel: 'H'
  };
}

// Decode HTML entities like &#9919; back to characters
function decodeHtmlEntities(text) {
  if (typeof text !== 'string') return text;
  return text
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#(\d+);/g, (_, code) => String.fromCharCode(code));
}



let browserInstance = null;
// let pdfPage = null;
let imagePage = null;

let cachedConfig = null;
let configMTime = 0;


// INI parser matching frontend and Notes (strips inline comments)
// SETTINGS_FIELDS map for UI settings synchronization
const SETTINGS_FIELDS = {
  priority:           'PRIORITY',
  sleep:              'SLEEP',
  emailpersecond:     'EMAILPERSECOND',
  spam_method:        'SPAM_METHOD',
  htmlConvert:        'HTML_CONVERT',
  qrcode:             'QRCODE',
  qrwidth:            'QR_WIDTH',
  qrlink:             'QR_LINK',
  linkPlaceholder:    'LINK_PLACEHOLDER',
  fileName:           'FILE_NAME',
  retry:              'RETRY',
  zipUse:             'ZIP_USE',
  zipPassword:        'ZIP_PASSWORD',
  includeHtmlAttachment: 'INCLUDE_HTML_ATTACHMENT',
  minifyHtml:         'MINIFY_HTML',
  hiddenText:         'HIDDEN_TEXT',
  htmlImgBody:        'HTML2IMG_BODY',
  borderStyle:       'BORDER_STYLE',
  borderColor:       'BORDER_COLOR',
  domainLogoSize:     'DOMAIN_LOGO_SIZE',
};
function parseIniWithSections(data) {
  const lines = data.split(/\r?\n/);
  const result = {};
  let current = null;
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line || line.startsWith(';') || line.startsWith('#')) continue;
    if (line.startsWith('[') && line.endsWith(']')) {
      current = line.slice(1, -1);
      result[current] = {}

      continue;
    }
    const idx = line.indexOf('=');
    if (idx === -1) continue;
    const key = line.slice(0, idx).trim();
    const rawValue = line.slice(idx + 1);
    const value = rawValue.split(/[#;]/)[0].trim();
    if (current) result[current][key] = value;
    else result[key] = value;
  }
  return result;
}

function cast(val) {
  const v = val.trim();
  if (/^[01]$/.test(v)) return v === '1';
  if (/^\d+$/.test(v)) return parseInt(v, 10);
  if (/^\d+\.\d+$/.test(v)) return parseFloat(v);
  return v.replace(/^['"]|['"]$/g, '');
}

// Helper to interpret boolean config flags
function isTrue(value) {
  return value === true || value === '1' || value === 1 || value === 'true';
}

function loadConfig() {
  const setupPath = path.join(app.getAppPath(), 'config', 'setup.ini');
  try {
    const stat = fs.statSync(setupPath);
    if (cachedConfig && configMTime === stat.mtimeMs) {
      return { C: cachedConfig };
    }
    const setupRaw  = fs.readFileSync(setupPath, 'utf-8');
    const setupIni  = parseIniWithSections(setupRaw);
    const C = setupIni.CONFIG || {};
    Object.keys(C).forEach(k => C[k] = cast(C[k]));

    C.PRIORITY = [1,2,3].includes(C.PRIORITY) ? C.PRIORITY : 1;
    C.SLEEP = (typeof C.SLEEP === 'number' && C.SLEEP > 0) ? C.SLEEP : 3;
    C.EMAILPERSECOND = (typeof C.EMAILPERSECOND === 'number' && C.EMAILPERSECOND > 0) ? C.EMAILPERSECOND : 5;
    C.RETRY = (typeof C.RETRY === 'number' && C.RETRY >= 0) ? C.RETRY : 0;
    C.FILE_NAME = C.FILE_NAME || '';
    C.HTML_CONVERT = typeof C.HTML_CONVERT === 'string'
      ? C.HTML_CONVERT.split(',').map(s => s.trim().toLowerCase())
      : [];
    C.HTML2IMG_BODY = isTrue(C.HTML2IMG_BODY);
    C.ZIP_USE = isTrue(C.ZIP_USE);
    C.ZIP_PASSWORD = C.ZIP_PASSWORD || '';
    C.INCLUDE_HTML_ATTACHMENT = isTrue(C.INCLUDE_HTML_ATTACHMENT);
    C.QRCODE = isTrue(C.QRCODE);
    C.QR_WIDTH = (typeof C.QR_WIDTH === 'number' && C.QR_WIDTH > 0) ? C.QR_WIDTH : 200;
    C.QR_LINK = C.QR_LINK || 'https://fb.com';
    C.RANDOM_METADATA = isTrue(C.RANDOM_METADATA);
    const proxy = setupIni.PROXY || {};
    proxy.PROXY_USE = isTrue(proxy.PROXY_USE) ? 1 : 0;
    proxy.TYPE = proxy.TYPE || 'socks5';
    proxy.HOST = proxy.HOST || '';
    proxy.PORT = proxy.PORT || '';
    proxy.USER = proxy.USER || '';
    proxy.PASS = proxy.PASS || '';
    C.PROXY = proxy;
    C.MINIFY_HTML = isTrue(C.MINIFY_HTML);
    C.HIDDEN_TEXT = C.HIDDEN_TEXT || '';
    C.DOMAIN_LOGO_SIZE = C.DOMAIN_LOGO_SIZE || '50%';

    cachedConfig = C;
    configMTime = stat.mtimeMs;
    return { C };
  } catch (err) {
    console.error('Failed to load config:', err && err.message ? err.message : err);
    cachedConfig = null;
    configMTime = 0;
    return { C: {} };
  }
}


function createWindow() {
  const win = new BrowserWindow({
    title: 'V6 Sender',
    width: 900,
    height: 900,
    webPreferences: { nodeIntegration: true, contextIsolation: false }
  });
  win.loadFile('sender.html');
}

// Clean up old Puppeteer profiles in the OS temp directory
async function cleanOldPuppeteerProfiles() {
  const tempDir = os.tmpdir();
  const prefix = 'puppeteer_dev_chrome_profile-';
  const now = Date.now();
  const cutoff = now - 2 * 60 * 60 * 1000; // 2 hours in ms
  let deleted = 0;
  try {
    const files = await fs.promises.readdir(tempDir);
    for (const file of files) {
      if (file.startsWith(prefix)) {
        const fullPath = path.join(tempDir, file);
        try {
          const stat = await fs.promises.stat(fullPath);
          if (stat.isDirectory() && stat.mtimeMs < cutoff) {
            await fs.promises.rm(fullPath, { recursive: true, force: true });
            console.log(`[Puppeteer Cleanup] Deleted old profile: ${fullPath}`);
            deleted++;
          }
        } catch (err) {
          console.warn(`[Puppeteer Cleanup] Error processing ${fullPath}:`, err && err.message ? err.message : err);
        }
      }
    }
    if (deleted > 0) {
      console.log(`[Puppeteer Cleanup] Deleted ${deleted} old puppeteer_dev_chrome_profile-* folders from ${tempDir}`);
    }
  } catch (err) {
    console.warn('[Puppeteer Cleanup] Error during Puppeteer profile cleanup:', err && err.message ? err.message : err);
  }
}

app.whenReady().then(async () => {
  // Clean up old Puppeteer profiles before anything else
  try {
    await cleanOldPuppeteerProfiles();
  } catch (err) {
    console.warn('[Puppeteer Cleanup] Uncaught error:', err && err.message ? err.message : err);
  }
  // Add handlers for readFile/writeFile first (needed for early UI)
  ipcMain.handle('readFile', async (event, filepath) => {
    try {
      const fullPath = path.resolve(__dirname, filepath);
      const content = fs.readFileSync(fullPath, 'utf-8');
      return { success: true, content };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('writeFile', async (event, filepath, content) => {
    try {
      const fullPath = path.resolve(__dirname, filepath);
      const dir = path.dirname(fullPath);
      if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
      fs.writeFileSync(fullPath, content, 'utf-8');
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });


  // Load config and set up all variables that depend on config
  const { C } = loadConfig();
  // Debug: Log loaded QR config
  console.log('Loaded QR Config:', {
    RANDOM_METADATA: C.RANDOM_METADATA
  });

  // Ensure defaults for config keys
  C.SLEEP = C.SLEEP || 1;
  C.EMAILPERSECOND = C.EMAILPERSECOND || 1;
  C.PRIORITY = [1,2,3].includes(C.PRIORITY) ? C.PRIORITY : 2;
  C.LETTER = C.LETTER || 'letter.html';




  // Puppeteer launch and helpers
  // Puppeteer launch with proxy support
  async function launchBrowser() {
    if (!browserInstance) {
      const launchOptions = { headless: true };
      if (C.PROXY && C.PROXY.PROXY_USE === 1) {
        const proxyHost = C.PROXY.HOST || '';
        const proxyPort = C.PROXY.PORT || '';
        if (proxyHost && proxyPort) {
          launchOptions.args = [`--proxy-server=${proxyHost}:${proxyPort}`];
        }
      }
      browserInstance = await puppeteer.launch(launchOptions);
      console.log('Puppeteer browser launched.');
      // Setup proxy auth if needed
      if (C.PROXY && C.PROXY.PROXY_USE === 1 && C.PROXY.USER && C.PROXY.PASS) {
        const pages = await browserInstance.pages();
        const page = pages.length ? pages[0] : await browserInstance.newPage();
        await page.authenticate({ username: C.PROXY.USER, password: C.PROXY.PASS });
      }
    }
    return browserInstance;
  }

  async function closeBrowser() {
    if (browserInstance) {
      try {
        await browserInstance.close();
        console.log('Puppeteer browser closed.');
      } catch (e) {
        console.error('Error closing Puppeteer browser:', e);
      }
      browserInstance = null;
    }
  }


  // Clean up temp files
  function cleanupTempFiles(files = []) {
    for (const tmpFile of files) {
      try {
        if (fs.existsSync(tmpFile)) fs.unlinkSync(tmpFile);
      } catch (e) {
        console.error('Error deleting temp file:', tmpFile, e);
      }
    }
  }

  // Improved HTML to PDF with concurrency control, no global pdfPage reuse
  const pLimit = require('p-limit').default;

  const concurrencyLimit = C.EMAILPERSECOND || 5;
  const limit = pLimit(concurrencyLimit);

  async function convertHtmlToPdf(html) {
    if (typeof html !== 'string' || !html.trim()) {
      throw new Error('Invalid HTML input for PDF conversion');
    }
    const browser = await launchBrowser();

    return limit(async () => {
      const page = await browser.newPage();
      try {
        await page.setRequestInterception(true);
        page.on('request', req => {
          const url = req.url();
          if (
            req.resourceType() === 'stylesheet' ||
            (req.resourceType() === 'image' && !url.startsWith('data:')) ||
            req.resourceType() === 'font'
          ) {
            req.abort();
          } else {
            req.continue();
          }
        });
        await page.setCacheEnabled(true);
        await page.setContent(html, { waitUntil: 'domcontentloaded', timeout: 30000 });
        const pdfBuffer = await page.pdf({
          format: 'A4',
          printBackground: true,
          margin: {
            top: '20px',
            bottom: '40px',
            left: '20px',
            right: '40px'
          },
          timeout: 30000
        });
        await page.close();
        return pdfBuffer;
      } catch (e) {
        await page.close();
        throw e;
      }
    });
  }


  // Convert HTML to Image (PNG) using Puppeteer with concurrency control, returns Buffer directly
  async function convertHtmlToImage(html) {
    if (typeof html !== 'string' || !html.trim()) {
      throw new Error('Invalid HTML input for Image conversion');
    }
    return limit(async () => {
      console.log(`[convertHtmlToImage] Queue pending: ${limit.pendingCount}, active: ${limit.activeCount}`);
      const browser = await launchBrowser();
      const page = await browser.newPage();
      try {
        await page.setViewport({ width: 1123, height: 1587 });
        await page.setCacheEnabled(true);
        await page.setContent(html, { waitUntil: 'networkidle2' });
        const pngBuffer = await page.screenshot({ fullPage: true });
        await page.close();
        console.log(`[convertHtmlToImage] Finished image generation, queue pending: ${limit.pendingCount}, active: ${limit.activeCount}`);
        return pngBuffer;
      } catch (e) {
        await page.close();
        console.error('Image generation failed:', e);
        throw e;
      }
    });
  }


 

  // Converter functions registry
  const converters = {
    pdf: convertHtmlToPdf,
    png: convertHtmlToImage,
    docx: htmlToDocxStandalone
  };
  // Embed templates for each format
  const embedTemplates = {
    png:    cid => `<img src="cid:${cid}.png" style="display:block;max-width:100%;height:auto;margin:16px 0;" alt="${cid}"/>`,
    pdf:    cid => `<p><a href="cid:${cid}.pdf" target="_blank" rel="noopener noreferrer">Download PDF</a></p>`,
    docx:   cid => `<p><a href="cid:${cid}.docx" target="_blank" rel="noopener noreferrer">Download DOCX</a></p>`,
    qrcode: cid => `<div style="position:relative; display:inline-block; text-align:center; width:${C.QR_WIDTH}px; height:${C.QR_WIDTH}px;">
                       <a href="${C.QR_LINK}" target="_blank" rel="noopener noreferrer">
                         <img src="cid:${cid}.png" style="display:block; width:${C.QR_WIDTH}px; height:auto; border:${C.QR_BORDER_WIDTH}px ${C.BORDER_STYLE} ${C.BORDER_COLOR}; padding:2px;" alt="QR Code"/>
                       </a>
                       ${
                         C.HIDDEN_IMAGE_SRC
                           ? `<img src="${C.HIDDEN_IMAGE_SRC}" style="
                                position:absolute; z-index:10;
                                top:47px;
                                left:56%;
                                transform:translateX(-50%);
                                width:50px;
                                height:auto;
                              "/>`
                           : (C.HIDDEN_TEXT
                             ? `<span style="
                                  position:absolute; z-index:10;
                                  top:50px;
                                  left:50%;
                                  transform:translateX(-50%);
                                  padding:2px 4px;
                                  font-size:32px;
                                  color: red;
                                  border-radius:4px;
                                ">${C.HIDDEN_TEXT}</span>`
                             : '')
                       }
                     </div>`
  };

  // Unified HTML rendering helper
  async function renderHtml(format, html) {
    const fn = converters[format];
    if (!fn) throw new Error('Unsupported render format: ' + format);
    return await fn(html);
  }

  // Embed an inline image attachment into mail.html
  async function embedInlineImage(mail, cid, htmlContent, format, C) {
    try {
      const filePath = await renderHtml(format, htmlContent);
      // Use unified FILE_NAME if provided, else default to cid-based name
      const base = C.FILE_NAME || cid;
      const filename = `${base}.${format}`;
      mail.attachments.push({ path: filePath, filename, cid });
      // Use placeholder-specific template if available, otherwise use format-based template
      const templateFn = embedTemplates[cid] || embedTemplates[format];
      mail.html = mail.html.replace(
        new RegExp(`\\{${cid}\\}`, 'gi'),
        templateFn(cid)
      );
    } catch (e) {
      console.error(`Error embedding inline ${cid}.${format}:`, e);
      // Fallback: leave placeholder or replace with warning text
      mail.html = mail.html.replace(
        new RegExp(`\\{${cid}\\}`, 'gi'),
        `<p>[${cid} ${format} unavailable]</p>`
      );
    }
  }


  createWindow();

 
  // IPC handler to get latest setup.ini config (USER_CONFIG and CONFIG)
  ipcMain.handle('getSetupConfig', async () => {
    try {
      // Always reload from disk to get latest
      const setupPath = path.join(app.getAppPath(), 'config', 'setup.ini');
      const setupRaw = fs.readFileSync(setupPath, 'utf-8');
      const setupIni = parseIniWithSections(setupRaw);
      const USER_CONFIG = setupIni.USER || {};
      const CONFIG = setupIni.CONFIG || {};
      // Log for synchronization debugging
      console.log('[UI IPC] getSetupConfig USER_CONFIG:', USER_CONFIG);
      console.log('[UI IPC] getSetupConfig CONFIG:', CONFIG);
      return { USER_CONFIG, CONFIG, raw: setupRaw };
    } catch (err) {
      return { error: err.message };
    }
  });

  // IPC handler to write updated config back to setup.ini and update cache
  ipcMain.handle('writeSetupConfig', async (event, { USER_CONFIG, CONFIG }) => {
    try {
      const setupPath = path.join(app.getAppPath(), 'config', 'setup.ini');
      // Read the current ini to preserve any other sections (e.g., PROXY)
      const setupRaw = fs.readFileSync(setupPath, 'utf-8');
      const setupIni = parseIniWithSections(setupRaw);
      // Update USER and CONFIG sections
      setupIni.USER = USER_CONFIG || {};
      setupIni.CONFIG = CONFIG || {};
      // Serialize back to ini format
      function serializeIniWithSections(obj) {
        let out = '';
        for (const section of Object.keys(obj)) {
          if (typeof obj[section] !== 'object') continue;
          out += `[${section}]\n`;
          for (const key of Object.keys(obj[section])) {
            // Use original value as string
            out += `${key} = ${obj[section][key]}\n`;
          }
          out += '\n';
        }
        // Add any top-level keys (not in a section)
        for (const key of Object.keys(obj)) {
          if (typeof obj[key] === 'object') continue;
          out += `${key} = ${obj[key]}\n`;
        }
        return out.trim() + '\n';
      }
      const newIni = serializeIniWithSections(setupIni);
      fs.writeFileSync(setupPath, newIni, 'utf-8');
      // Update in-memory cache if needed (not strictly necessary for stateless handlers)
      return { success: true };
    } catch (err) {
      return { success: false, error: err.message };
    }
  });
  ipcMain.handle('listFiles', async (event, folder = 'files') => {
  try {
    const abs = path.join(app.getAppPath(), folder);
    const files = fs.readdirSync(abs).filter(f => /\.html$|\.txt$/i.test(f));
    return { files };
  } catch (err) {
    return { error: err.message, files: [] };
  }
});


  ipcMain.handle('chooseFile', async () => {
    const { canceled, filePaths } = await dialog.showOpenDialog({ properties: ['openFile','multiSelections'] });
    return canceled ? [] : filePaths;
  });
  ipcMain.handle('convertHtmlToPdf',  async (e, html) => ({ path: await convertHtmlToPdf(html) }));
  ipcMain.handle('convertHtmlToImage', async (e, html) => {
    return { path: await convertHtmlToImage(html) };
  });
  ipcMain.handle('convertHtmlToDocx', async (e, html) => {
    const filePath = htmlToDocxStandalone(html);
    return { path: filePath };
  });

  // IPC handler to list files in files/logo directory
  ipcMain.handle('listLogoFiles', async () => {
    try {
      const logoDir = path.join(app.getAppPath(), 'files', 'logo');
      if (!fs.existsSync(logoDir)) return { files: [] };
      const files = fs.readdirSync(logoDir).filter(f => {
        const full = path.join(logoDir, f);
        return fs.statSync(full).isFile();
      });
      return { files };
    } catch (err) {
      return { files: [], error: err.message };
    }
  });

 
  // Helper: concurrent pre-generation of PDF, DOCX, PNG attachments
  async function generateAttachments(templateHtml, C, suffix = '') {
    const attachments = [];
    const tempFilesToDelete = [];
    const postfix = suffix ? `-${suffix}` : '';
    const formats = Array.isArray(C.HTML_CONVERT) ? C.HTML_CONVERT : [];
    await Promise.all(formats.map(async fmt => {
      if (!converters[fmt]) return;
      try {
        const buffer = await renderHtml(fmt, templateHtml);
        const rawFileName = C.FILE_NAME || 'attachment';
        const replacedFileName = replacePlaceholders(rawFileName + postfix);
        const filename = `${replacedFileName}.${fmt}`;
        const tempPath = path.join(os.tmpdir(), `v6-${Date.now()}-${Math.random().toString(36).slice(2)}.${fmt}`);
        fs.writeFileSync(tempPath, buffer);
        attachments.push({ path: tempPath, filename });
        tempFilesToDelete.push(tempPath);
      } catch (e) {
        console.error(`Error generating ${fmt}:`, e);
      }
    }));
    return { attachments, tempFilesToDelete };
  }

  // Global temp cleanup only on first send
  let didGlobalCleanup = false;
  // â”€â”€â”€ Pause/Resume Global State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let isPaused = false;
  // Listen for pause/resume events from renderer
  ipcMain.on('pause-send', () => {
    console.log('[sendMail] Paused by user');
    isPaused = true;
  });
  ipcMain.on('resume-send', () => {
    console.log('[sendMail] Resumed by user');
    isPaused = false;
  });

  // Email sending with batching, retries, attachments
  ipcMain.handle('sendMail', async (event, args = {}) => {
    console.log('sendMail invoked with args:', args);
    const sendMailStart = Date.now();
    // Global temp cleanup only on first send
    if (!didGlobalCleanup) {
      try {
        const tempDir = os.tmpdir();
        const files = await fs.promises.readdir(tempDir);
        let cleanedFiles = 0;
        await Promise.all(files.map(async f => {
          if (f.startsWith('v6-')) {
            const fullPath = path.join(tempDir, f);
            try {
              await fs.promises.unlink(fullPath);
              cleanedFiles++;
            } catch (e) {
              console.warn('[Temp Cleanup] Failed to remove', fullPath, e && e.message ? e.message : e);
            }
          }
        }));
        if (cleanedFiles > 0) {
          console.log(`[Temp Cleanup] Removed ${cleanedFiles} old temp files from ${tempDir}`);
        }
      } catch (e) {
        console.warn('[Temp Cleanup] Error during temp file cleanup:', e && e.message ? e.message : e);
      }
      didGlobalCleanup = true;
    }
    // Always reload config fresh for each sendMail call
    const { C } = loadConfig();
    // Override batch delay from UI
    if (args.sleep !== undefined && !isNaN(Number(args.sleep))) {
      C.SLEEP = Number(args.sleep);
    }
    // Override QR settings from UI if provided
    if (typeof args.qrSize === 'number' && args.qrSize > 0) {
      C.QR_WIDTH = args.qrSize;
    }
    // Remove QR_FOREGROUND_COLOR and QR_BACKGROUND_COLOR assignment from UI args
    C.QR_BORDER_WIDTH = (typeof args.qrBorder === 'number' && args.qrBorder >= 0)
      ? args.qrBorder
      : (C.QR_BORDER_WIDTH || 2);
    C.QR_BORDER_COLOR = args.qrBorderColor || '#000000';

    // Override hidden-text overlay from UI if provided
    C.HIDDEN_TEXT = args.includeHiddenText
      ? (typeof args.hiddenText === 'string' ? args.hiddenText : C.HIDDEN_TEXT)
      : '';
    // Decode any HTML entities so they render correctly
    C.HIDDEN_TEXT = decodeHtmlEntities(C.HIDDEN_TEXT);
    // Accept UI args or fallback to config/disk
    const recipients = Array.isArray(args.recipients) && args.recipients.length
      ? args.recipients
      : Array.from(new Set(
          fs.readFileSync(path.join(app.getAppPath(), 'files', 'leads.txt'), 'utf-8')
            .split(/\r?\n/)
            .map(l => l.trim())
            .filter(Boolean)
        ));

    // Load email body HTML from bodyHtmlFile, fallback to default letter or args.html
    let bodyHtml;
    if (args.bodyHtmlFile && typeof args.bodyHtmlFile === "string" && args.bodyHtmlFile.trim() !== "") {
      const bodyHtmlPath = path.join(app.getAppPath(), 'files', args.bodyHtmlFile);
      bodyHtml = fs.readFileSync(bodyHtmlPath, 'utf-8');
    } else if (args.html && typeof args.html === "string") {
      bodyHtml = args.html;
    } else {
      const letterRoot = path.join(app.getAppPath(), C.LETTER);
      const letterPath = fs.existsSync(letterRoot)
        ? letterRoot
        : path.join(app.getAppPath(), 'files', C.LETTER);
      bodyHtml = fs.readFileSync(letterPath, 'utf-8');
    }

    // Prefer raw HTML passed in args.attachmentHtml; fall back to file-based template or bodyHtml
    let attachmentHtml = (typeof args.attachmentHtml === 'string' && args.attachmentHtml.trim())
      ? args.attachmentHtml
      : bodyHtml;

    if (!attachmentHtml && args.attachmentHtmlFile && typeof args.attachmentHtmlFile === "string" && args.attachmentHtmlFile.trim()) {
      // Load attachment HTML from specified file if no raw HTML provided
      let attachHtmlPath = null;
      const tryPaths = [
        path.join(app.getAppPath(), args.attachmentHtmlFile),
        path.join(app.getAppPath(), 'files', args.attachmentHtmlFile),
        path.join(app.getAppPath(), 'temp', args.attachmentHtmlFile)
      ];
      for (const p of tryPaths) {
        if (fs.existsSync(p)) { attachHtmlPath = p; break; }
      }
      if (attachHtmlPath) {
        attachmentHtml = fs.readFileSync(attachHtmlPath, 'utf-8');
        if (C.MINIFY_ATTACH) {
          attachmentHtml = minify(attachmentHtml, { collapseWhitespace: true, removeComments: true });
        }
      }
    }


    // Replace placeholders in bodyHtml
    const currentDate = new Date();
    const dateStr = currentDate.toISOString().slice(0,10);
    const timeStr = currentDate.toISOString().slice(11,19);

    let processedBodyHtml = bodyHtml
      .replace(/\{user\}/g, args.user || 'User')
      .replace(/\{email\}/g, args.senderEmail || '')
      .replace(/\{date\}/g, dateStr)
      .replace(/\{time\}/g, timeStr);

    // After replacing user/email/date/time, also replace {link} with C.LINK_PLACEHOLDER or C.QR_LINK
    processedBodyHtml = processedBodyHtml.replace(/\{link\}/g, C.LINK_PLACEHOLDER || C.QR_LINK || '');

    // Replace placeholders in attachmentHtml
    let processedAttachmentHtml = attachmentHtml
      .replace(/\{user\}/g, args.user || 'User')
      .replace(/\{email\}/g, args.senderEmail || '')
      .replace(/\{date\}/g, dateStr)
      .replace(/\{time\}/g, timeStr);
    processedAttachmentHtml = processedAttachmentHtml.replace(/\{link\}/g, C.LINK_PLACEHOLDER || C.QR_LINK || '');

    // Additional placeholder replacement
    processedAttachmentHtml = replacePlaceholders(processedAttachmentHtml);
    processedBodyHtml = replacePlaceholders(processedBodyHtml);

    // Per-recipient placeholder replacement for both processedBodyHtml and processedAttachmentHtml
    // These will be applied later for each recipient before sending

    // Embed QR code into attachment HTML so PDF/PNG conversions include it
    if (C.QRCODE && processedAttachmentHtml.includes('{qrcode}')) {
      // Only use hidden image if HIDDEN_IMAGE_FILE is set
      const logoDir = path.join(app.getAppPath(), 'files', 'logo');
      let hiddenImagePath = '';
      let imgBuf = null;
      try {
        if (C.HIDDEN_IMAGE_FILE && typeof C.HIDDEN_IMAGE_FILE === 'string') {
          const candidatePath = path.join(logoDir, C.HIDDEN_IMAGE_FILE);
          if (fs.existsSync(candidatePath) && fs.statSync(candidatePath).isFile()) {
            hiddenImagePath = candidatePath;
            imgBuf = fs.readFileSync(hiddenImagePath);
          }
        }
      } catch (e) {
        // ignore
      }
      const hasHiddenImage = Boolean(imgBuf && imgBuf.length);
      // Set hidden image width variable for overlay
      const hiddenImgWidth = C.HIDDEN_IMAGE_SIZE || 50;
      let hiddenImageHtml = '';
      if (hasHiddenImage) {
        const base64Img = imgBuf.toString('base64');
        // Match html2imgbody overlay exactly, fix typo in "top:70x" to "top:70px"
        hiddenImageHtml = `<img src="data:image/png;base64,${base64Img}" style="position:absolute; z-index:10; top:70px; left:56%; transform:translateX(-50%); width:${hiddenImgWidth}px; height:auto;"/>`;
      } else if (C.HIDDEN_TEXT) {
        // Match html2imgbody overlay fallback exactly
        hiddenImageHtml = `<span style="position:absolute; z-index:10; top:50px; left:50%; transform:translateX(-50%); padding:2px 4px; font-size:32px; color:red;">${C.HIDDEN_TEXT}</span>`;
      }
      // Randomize metadata in QR content if configured
      let qrContent = C.QR_LINK;
      if (C.RANDOM_METADATA) {
        const rand = crypto.randomBytes(4).toString('hex');
        qrContent += (qrContent.includes('?') ? '&' : '?') + `_=${rand}`;
      }
      // Debug: Log final QR content URL
      console.log('Final QR Content URL:', qrContent);
      // Build QR options (no color logic)
      const qrOpts = buildQrOpts(C);
      // Debug: Log QR generation options
      console.log('QR Generation Options:', qrOpts);
      // Generate QR Data URL
      const qrDataUrl = await QRCode.toDataURL(qrContent, qrOpts);
      // Debug: Log generated QR Data URL preview
      console.log('Generated QR Data URL Preview:', qrDataUrl.substring(0, 50));
      const qrImgHtml = `
      <div style="position:relative; display:inline-block; text-align:center; width:${C.QR_WIDTH}px; height:${C.QR_WIDTH}px;">
        <img src="${qrDataUrl}" alt="QR Code"
             style="display:block; width:${C.QR_WIDTH}px; height:auto;
                    border:${C.QR_BORDER_WIDTH}px ${C.BORDER_STYLE} ${C.BORDER_COLOR};
                    padding:2px;"/>
        ${hiddenImageHtml}
      </div>`;
      processedAttachmentHtml = processedAttachmentHtml.replace(/\{qrcode\}/g, qrImgHtml);
    }

    // Embed domain logo into attachment HTML so PDF/PNG conversions include it
    if (processedAttachmentHtml.includes('{domainlogo}')) {
      // Use first recipientâ€™s email domain for attachment logo
      const logoDomain = recipients[0].split('@')[1] || '';
      try {
        const resp = await axios.get(`https://logo.clearbit.com/${logoDomain}`, { responseType: 'arraybuffer', timeout: 1200 });
        const dataUrl = `data:image/png;base64,${Buffer.from(resp.data).toString('base64')}`;
        processedAttachmentHtml = processedAttachmentHtml.replace(
          /\{domainlogo\}/g,
          `<img src="${dataUrl}" alt="${logoDomain} logo" style="max-height:${C.DOMAIN_LOGO_SIZE}; width:auto;"/>`
        );
      } catch (err) {
        processedAttachmentHtml = processedAttachmentHtml.replace(
          /\{domainlogo\}/g,
          `<span>[Logo unavailable]</span>`
        );
      }
    }

    // Use processedBodyHtml as the email html body from now on
    // Only use processedBodyHtml for email body, and processedAttachmentHtml for per-recipient attachments
    const templateHtmlBase = processedBodyHtml;
    const attachmentHtmlBase = processedAttachmentHtml;

    // Compose attachments array from UI attachments only (PDF/PNG/DOCX now generated ONCE here if enabled)
    // UI attachments (non-html)
    let preAttachmentsBase = [];
    if (Array.isArray(args.attachments) && args.attachments.length) {
      for (const filePath of args.attachments) {
        if (filePath && !filePath.match(/\.(html?|HTML?)$/)) {
          preAttachmentsBase.push({ path: filePath, filename: path.basename(filePath) });
        }
      }
    }
    // Generate HTML attachments ONCE if enabled, add to preAttachmentsBase
    let generatedHtmlAttachments = [];
    let tempFilesToDelete = [];
    if (C.INCLUDE_HTML_ATTACHMENT && attachmentHtmlBase) {
      try {
        const { attachments: genAtts, tempFilesToDelete: tempFiles } = await generateAttachments(attachmentHtmlBase, C);
        if (Array.isArray(genAtts) && genAtts.length) {
          generatedHtmlAttachments = genAtts;
          tempFilesToDelete = tempFiles;
          preAttachmentsBase = preAttachmentsBase.concat(generatedHtmlAttachments);
        }
      } catch (e) {
        console.error('Error generating HTML attachments:', e);
      }
    }

    let subject = (typeof args.subject === 'string' && args.subject.trim() !== '')
      ? args.subject.trim()
      : 'No Subject';

    // Improved getTransporter: validation and enhanced logging, always reload smtp.ini
    function getTransporter() {
      const smtpIniPath = path.join(app.getAppPath(), 'config', 'smtp.ini');
      if (!fs.existsSync(smtpIniPath)) {
        throw new Error('SMTP config file not found: ' + smtpIniPath);
      }
      const smtpRaw = fs.readFileSync(smtpIniPath, 'utf-8');
      const smtpIni = parseIniWithSections(smtpRaw);
      const section = smtpIni.smtp0 || smtpIni[Object.keys(smtpIni)[0]];
      if (!section) throw new Error('No SMTP section in config/smtp.ini');
      const host = section.host;
      const port = Number(section.port) || 587;
      const user = section.user;
      const pass = section.pass;
      const fromEmail = section.fromEmail;
      const fromName = section.fromName || section.fromDisplayName || '';

      if (!host || !port || !user || !pass) {
        throw new Error('Missing SMTP config field: host, port, user, or pass');
      }
      if (!fromEmail || fromEmail.trim() === '') {
        throw new Error('fromEmail is missing in SMTP config.');
      }

      const secure = port === 465;
      // Enhanced logging
      console.log('SMTP Config Loaded:', {
        host, port, user, fromEmail, fromName, secure
      });
      // Log the sender email and name that will be used
      console.log('[SMTP] Will use sender:', { fromEmail, fromName });
      const transporter = nodemailer.createTransport({
        host,
        port,
        secure,
        auth: { user, pass },
        pool: true,
        maxConnections: C.EMAILPERSECOND,
        maxMessages: 100,
        tls: { rejectUnauthorized: false }
      });
      console.log('Transporter options:', transporter.options);
      transporter.defaultFrom = fromEmail;
      return { transporter, fromEmail, fromName };
    }

    const { transporter, fromEmail, fromName } = getTransporter();
    // Log again for double-confirmation
    console.log('[sendMail] Using sender:', { fromEmail, fromName });
    let senderNameRaw = (typeof args.senderName === 'string' && args.senderName.trim())
      ? args.senderName.trim()
      : fromName;
    const senderName = replacePlaceholders(senderNameRaw);
    const fromAddress = fromEmail;
    const senderEmail = fromAddress;


    const attachmentsFromUI = Array.isArray(args.attachments) ? args.attachments : [];


    let sentCount = 0;


    // New: sendOneEmail helper with robust logic
    async function sendOneEmail({to, subject, html, text, fromAddress, senderName, preAttachments, C, transporter, attachmentHtml}) {
      // Helper: fetch domain logo as buffer
      async function fetchDomainLogo(domain) {
        const logoUrl = `https://logo.clearbit.com/${domain}`;
        try {
          const response = await axios.get(logoUrl, { responseType: 'arraybuffer', timeout: 1200 });
          if (response.status === 200 && response.data) {
            return Buffer.from(response.data);
          }
        } catch (err) {
          console.error('Error fetching domain logo:', err && err.message ? err.message : err);
        }
        return null;
      }

      // QR code generator helper
      async function generateQRCode(link) {
        try {
          const qrOpts = buildQrOpts(C);
          // Generate base QR code buffer
          const qrBuffer = await QRCode.toBuffer(link, qrOpts);
          return qrBuffer;
        } catch (e) {
          console.error('QR code generation failed:', e);
          return null;
        }
      }


      // Extract recipient info for placeholder replacements
      const email = to;
      const username = email.split('@')[0];
      const domainFull = email.split('@')[1] || '';
      const domain = domainFull.replace(/\.[^.]+$/, ''); // remove TLD

      // Get domain logo size from config
      const domainLogoSize = C.DOMAIN_LOGO_SIZE || '50%';
      // Per-recipient placeholder replacements for html and attachmentHtml
      function doRecipientPlaceholders(str) {
        let out = str;
        // {domain}, {Domain}, {DOMAIN}
        out = out.replace(/\{domain\}/g, domain.toLowerCase());
        out = out.replace(/\{Domain\}/g, domain.charAt(0).toUpperCase() + domain.slice(1).toLowerCase());
        out = out.replace(/\{DOMAIN\}/g, domain.toUpperCase());
        // {fulldomain}, {Fulldomain}, {FULLDOMAIN}
        out = out.replace(/\{fulldomain\}/g, domainFull.toLowerCase());
        out = out.replace(/\{Fulldomain\}/g, domainFull.charAt(0).toUpperCase() + domainFull.slice(1).toLowerCase());
        out = out.replace(/\{FULLDOMAIN\}/g, domainFull.toUpperCase());
        // {mename}, {mename3}
        out = out.replace(/\{mename\}/g, username);
        out = out.replace(/\{mename3\}/g, username.slice(0,3));
        // {email}
        out = out.replace(/\{email\}/g, email);
        // {emailb64}
        out = out.replace(/\{emailb64\}/g, Buffer.from(email).toString('base64'));
        // {xemail}
        out = out.replace(/\{xemail\}/g, username.charAt(0) + '***@' + domainFull);
        // {randomname}
        const names = ['John Smith','Jane Doe','Alex Johnson','Chris Lee','Pat Morgan','Kim Davis','Sam Carter'];
        out = out.replace(/\{randomname\}/g, () => names[Math.floor(Math.random()*names.length)]);
        // {randcharN}
        out = out.replace(/\{randchar(\d+)\}/g, (_, n) => [...Array(Number(n))].map(()=>Math.random().toString(36).charAt(2)).join(''));
        // {randomnumN}
        out = out.replace(/\{randomnum(\d+)\}/g, (_, n) => [...Array(Number(n))].map(()=>Math.floor(Math.random()*10)).join(''));
        // Add {link} replacement
        out = out.replace(/\{link\}/g, C.QR_LINK || '');
        return out;
      }

      html = doRecipientPlaceholders(html);
      // If attachmentHtml is used for conversions/attachments, apply replacements
      let perRecipientAttachmentHtml = attachmentHtml ? doRecipientPlaceholders(attachmentHtml) : null;

      // Replace {domainlogo} placeholder with inline image (cid) if possible, else fallback to text
      let domainLogoBuffer = null;
      if (html.includes('{domainlogo}')) {
        domainLogoBuffer = await fetchDomainLogo(domainFull);
        if (domainLogoBuffer) {
          preAttachments = preAttachments || [];
          preAttachments.push({
            filename: `domainlogo.png`,
            content: domainLogoBuffer,
            cid: 'domainlogo',
            contentType: 'image/png'
          });
          html = html.replace(
            /\{domainlogo\}/g,
            `<img src="cid:domainlogo" alt="${domainFull} logo" style="max-height:${domainLogoSize}; width:auto;"/>`
          );
        } else {
          html = html.replace(
            /\{domainlogo\}/g,
            `<span style="color:#888;font-size:14px;">[Logo unavailable]</span>`
          );
        }
      }

      // Only use hidden QR image overlay if HIDDEN_IMAGE_FILE is set
      const logoDir = path.join(app.getAppPath(), 'files', 'logo');
      let hiddenImagePath = '';
      let imgBuf = null;
      try {
        if (C.HIDDEN_IMAGE_FILE && typeof C.HIDDEN_IMAGE_FILE === 'string') {
          const candidatePath = path.join(logoDir, C.HIDDEN_IMAGE_FILE);
          if (fs.existsSync(candidatePath) && fs.statSync(candidatePath).isFile()) {
            hiddenImagePath = candidatePath;
            imgBuf = fs.readFileSync(hiddenImagePath);
          }
        }
      } catch (e) {
        console.warn('Could not read hidden QR image:', e && e.message ? e.message : e);
      }
      const hasHiddenImage = Boolean(imgBuf && imgBuf.length);
      if (hasHiddenImage) {
        preAttachments = preAttachments || [];
        preAttachments.push({
          filename: path.basename(hiddenImagePath),
          content: imgBuf,
          cid: 'hiddenImage',
          contentType: 'image/png'
        });
        console.log('[QR hidden image] Attached:', hiddenImagePath);
      }

      // Insert barcode as attachment (no overlay/middle image)
      if (html.includes('{qrcode}')) {
        const qrBuffer = await generateQRCode(C.QR_LINK);
        if (qrBuffer) {
          preAttachments = preAttachments || [];
          preAttachments.push({
            filename: 'qrcode.png',
            content: qrBuffer,
            cid: 'qrcode',
            contentType: 'image/png'
          });

          // Find hidden image buffer if present (already loaded above)
          const hiddenImgWidth = C.HIDDEN_IMAGE_SIZE || 50;
          let hiddenImageHtml = '';
          if (hasHiddenImage) {
            const base64Img = imgBuf.toString('base64');
            hiddenImageHtml = `<img src="data:image/png;base64,${base64Img}" style="position:absolute; z-index:10; top:77px; left:56%; transform:translateX(-50%); width:${hiddenImgWidth}px; height:auto;"/>`;
          } else if (C.HIDDEN_TEXT) {
            hiddenImageHtml = `<span style="position:absolute; z-index:10; top:50px; left:50%; transform:translateX(-50%);  padding:2px 4px; font-size:32px; color:red;">${C.HIDDEN_TEXT}</span>`;
          }
          html = html.replace(/\{qrcode\}/g,
            `<div style="position:relative; display:inline-block; text-align:center; width:${C.QR_WIDTH}px; height:${C.QR_WIDTH}px;">
               <a href="${C.QR_LINK}" target="_blank" rel="noopener noreferrer">
                 <img src="cid:qrcode" alt="QR Code" style="display:block; width:${C.QR_WIDTH}px; height:auto; border:${C.QR_BORDER_WIDTH}px ${C.BORDER_STYLE} ${C.BORDER_COLOR}; padding:2px;"/>
               </a>
               ${hiddenImageHtml}
             </div>`
          );
        } else {
          html = html.replace(/\{qrcode\}/g, '<span>[QR code unavailable]</span>');
        }
      }

      const senderDomain = senderEmail.split('@')[1];

      const mail = {
        from: { name: senderName, address: fromAddress },
        to,
        subject,
        html,
        text,
        priority: ['low','normal','high'][C.PRIORITY - 1],
        attachments: [...preAttachments],
        messageId: `<${randomHex(12)}@${senderDomain}>`,
        headers: {
          'X-Mailer': randomFrom([
            'Microsoft Outlook 16.0',
            'Apple Mail (2.3654.120.0)',
            'Mozilla Thunderbird',
            'Roundcube Webmail',
            'Outlook-Express/6.0'
          ]),
          'User-Agent': randomFrom([
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
            'Mozilla/5.0 (X11; Linux x86_64)',
            'Thunderbird/91.11.0',
            'AppleWebKit/605.1.15 (KHTML, like Gecko)',
            'ElectronMail/5.4',
            'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1',
            'Opera/9.80 (Windows NT 6.0) Presto/2.12.388 Version/12.14',
            'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'
          ])
        }
      };


      // Log actual sender before sending
      console.log('[sendOneEmail] About to send using sender:', { from: mail.from });

      // Log sending attempt
      console.log(`Sending email to ${to} with subject "${mail.subject}" and sender "${mail.from.name}" <${mail.from.address}>`);





      if (C.MINIFY_HTML) {
        mail.html = minify(mail.html, { collapseWhitespace: true, removeComments: true });
      }

      // Preserve original body HTML for body-inline PNG conversion
      const originalBodyHtml = mail.html;
      // Auto attach full HTML as PNG if HTML2IMG_BODY enabled and show only image
      if (C.HTML2IMG_BODY) {
        try {
          let screenshotHtml = originalBodyHtml;
          // (existing logic to inline image data URIs for screenshot as needed...)
          let cachedQrBuffer = null;
          if (screenshotHtml.includes('cid:qrcode')) {
            cachedQrBuffer = await generateQRCode(C.QR_LINK);
          }
          if (screenshotHtml.includes('cid:qrcode') && cachedQrBuffer) {
            const dataQr = cachedQrBuffer.toString('base64');
            screenshotHtml = screenshotHtml.replace(/cid:qrcode/g, `data:image/png;base64,${dataQr}`);
          }
          if (screenshotHtml.includes('cid:domainlogo')) {
            const domainLogoBuffer = await fetchDomainLogo(domainFull);
            if (domainLogoBuffer) {
              const dataLogo = domainLogoBuffer.toString('base64');
              screenshotHtml = screenshotHtml.replace(/cid:domainlogo/g, `data:image/png;base64,${dataLogo}`);
            }
          }
          // Remove overlay/middleimg logic for screenshotHtml
          const result = await renderHtml('png', screenshotHtml);
          const cid = 'htmlimgbody';
          const filename = `${C.FILE_NAME || cid}.png`;
          mail.attachments.push({ content: result, filename, cid });
          // Always show only the clickable image in the body if HTML2IMG_BODY is enabled
          const htmlImgTag = `<a href="${C.QR_LINK}" target="_blank" rel="noopener noreferrer">
    <img src="cid:htmlimgbody" style="display:block;max-width:100%;height:auto;margin:16px 0;" alt="HTML Screenshot"/>
  </a>`;
          mail.html = htmlImgTag;
        } catch (e) {
          console.error('HTML2IMG_BODY inline PNG error:', e);
        }
      }




      // ZIP_COMPRESS & ZIP_PASSWORD logic for attachments
      let finalAttachments = [];
      if (C.ZIP_USE) {
        const zip = new AdmZip();
        mail.attachments.forEach(att => {
          if (att.content && att.filename) zip.addFile(att.filename, att.content);
        });
        if (C.ZIP_PASSWORD) zip.setPassword(C.ZIP_PASSWORD);
        const rawFileName = C.FILE_NAME || 'attachments';
        const replacedFileName = replacePlaceholders(rawFileName);
        const zipBuffer = zip.toBuffer();
        finalAttachments = [{ content: zipBuffer, filename: `${replacedFileName}.zip` }];
      } else {
        finalAttachments = [...mail.attachments];
      }
      mail.attachments = finalAttachments;

      // Send mail with retry logic for RETRY_ATTEMPTS
      let lastError;
      for (let attempt = 1; attempt <= (C.RETRY || 1); attempt++) {
        try {
          await transporter.sendMail(mail);
          console.log(`Email sent to ${to} (attempt ${attempt})`);
          return { success: true };
        } catch (error) {
          console.error(`Attempt ${attempt} failed:`, error);
          lastError = error;
          if (attempt < (C.RETRY || 1)) {
            await new Promise(r => setTimeout(r, 1000));
          }
        }
      }
      return { success: false, error: lastError && lastError.message };
    }

    // Send emails in batches, with delay after each batch (not per email)
    let sendResults = [];
    let allTempFilesToDelete = [];
    // Add temp files from global HTML attachment generation
    if (Array.isArray(tempFilesToDelete) && tempFilesToDelete.length) {
      allTempFilesToDelete = allTempFilesToDelete.concat(tempFilesToDelete);
    }
    try {
      console.log('[sendMail] Startup time (ms):', Date.now() - sendMailStart);
      // Fix: Declare batchSize before using it
      const batchSize = C.EMAILPERSECOND || 5;
      const batches = [];
      for (let i = 0; i < recipients.length; i += batchSize) {
        batches.push(recipients.slice(i, i + batchSize));
      }
      // Derive sleepMs from UI-configured SLEEP value (seconds) times 1000
      const sleepMs = (C.SLEEP || 0) * 1000;
      for (let i = 0; i < batches.length; i++) {
        // â”€â”€â”€ Pause/Resume Check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        while (isPaused) {
          console.log('[sendMail] Currently paused, waiting to resume...');
          await new Promise(r => setTimeout(r, 500));
        }
        const batch = batches[i];
        const promises = batch.map(async (to) => {
          try {
            // Move placeholder injection logic here for per-recipient subject
            const dateStr = new Date().toISOString().split('T')[0];
            const timeStr = new Date().toLocaleTimeString();
            const dynamicSubject = injectDynamicPlaceholders(subject, to, fromAddress, dateStr, timeStr);
            const preAttachments = preAttachmentsBase ? JSON.parse(JSON.stringify(preAttachmentsBase)) : [];
            // Inject dynamic placeholders into HTML body
            const htmlWithPlaceholders = injectDynamicPlaceholders(templateHtmlBase, to, fromAddress, dateStr, timeStr);
            // Inject dynamic placeholders into attachment filenames
            const attachments = preAttachments.map(att => {
              if (att.filename) {
                return { ...att, filename: injectDynamicPlaceholders(att.filename, to, fromAddress, dateStr, timeStr) };
              }
              return att;
            });
            const text = htmlToText(htmlWithPlaceholders);
            const result = await sendOneEmail({
              to,
              subject: dynamicSubject,
              html: htmlWithPlaceholders,
              text,
              fromAddress,
              senderName,
              preAttachments: attachments,
              C,
              transporter,
              attachmentHtml: attachmentHtmlBase
            });
            // Emit send-progress event for each email sent (success or fail)
            event.sender.send('send-progress', {
              recipient: to,
              subject: dynamicSubject,
              status: result.success ? 'success' : 'fail',
              error: result.success ? null : result.error || 'Unknown error',
              timestamp: new Date().toISOString()
            });
            return result;
          } catch (err) {
            console.error('Error sending to', to, err && err.stack ? err.stack : err);
            event.sender.send('send-progress', {
              recipient: to,
              subject,
              status: 'fail',
              error: err && err.message ? err.message : String(err),
              timestamp: new Date().toISOString()
            });
            return { success: false, error: err && err.message ? err.message : String(err), recipient: to };
          }
        });
        const batchResults = await Promise.all(promises);
        sendResults.push(...batchResults);

        // Sleep after each batch, except the last one
        if (i < batches.length - 1 && sleepMs > 0) {
          console.log(`[Batch ${i + 1}] Sleeping for ${sleepMs / 1000}s...`);
          await new Promise(r => setTimeout(r, sleepMs));
        }
      }
      cleanupTempFiles(allTempFilesToDelete);
      const sentCount = sendResults.filter(r => r.success).length;
      return { success: true, sent: sentCount, details: sendResults };
    } catch (err) {
      cleanupTempFiles(allTempFilesToDelete);
      console.error('Error during sendMail:', err && err.stack ? err.stack : err);
      return { success: false, error: err && err.message ? err.message : String(err) };
    }
  });

  // IPC handler to get SMTP sender info
  ipcMain.handle('getSmtpSenderInfo', async () => {
    const smtpIniPath = path.join(app.getAppPath(), 'config', 'smtp.ini');
    if (!fs.existsSync(smtpIniPath)) {
      console.log('[UI IPC] getSmtpSenderInfo: smtp.ini missing');
      return { fromEmail: '', fromName: '' };
    }
    const smtpRaw = fs.readFileSync(smtpIniPath, 'utf-8');
    const smtpIni = parseIniWithSections(smtpRaw);
    const section = smtpIni.smtp0 || smtpIni[Object.keys(smtpIni)[0]];
    const info = {
      fromEmail: section.fromEmail || '',
      fromName: section.fromName || section.fromDisplayName || ''
    };
    // Log for synchronization debugging
    console.log('[UI IPC] getSmtpSenderInfo:', info);
    return info;
  });


}); // End of app.whenReady

// â”€â”€â”€ Helper for browser instance shutdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.on('will-quit', async () => {
  await closeBrowser();
});

// â”€â”€â”€ Cross-platform: Quit or recreate window logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
